## CometBFT

CometBFT是一个与应用程序无关的引擎，负责处理区块链的网络层和共识层。在实践中，这意味着CometBFT负责传播和排序事务字节。CometBFT依赖于同名的拜占庭容错（BFT）算法来就事务顺序达成共识。

CometBFT共识算法使用一组称为Validators的特殊节点。验证器负责将交易块添加到区块链中。在任何给定的块上，都有一个验证器集V。算法选择V中的验证器作为下一个块的提议者。如果超过三分之二的V在其上签署了prevote和precommit，并且它包含的所有事务都是有效的，则该块被认为是有效的。验证程序集可以通过在状态机中编写的规则进行更改。

```markdown
                ^  +-------------------------------+  ^
                |  |                               |  |   Built with Cosmos SDK
                |  |  State-machine = Application  |  |
                |  |                               |  v
                |  +-------------------------------+
                |  |                               |  ^
Blockchain node |  |           Consensus           |  |
                |  |                               |  |
                |  +-------------------------------+  |   CometBFT
                |  |                               |  |
                |  |           Networking          |  |
                |  |                               |  |
                v  +-------------------------------+  v
```

## ABCI

CometBFT通过一个名为ABCI的接口将事务传递给应用程序，应用程序必须实现ABCI.

```markdown
              +---------------------+
              |                     |
              |     Application     |
              |                     |
              +--------+---+--------+
                       ^   |
                       |   | ABCI
                       |   v
              +--------+---+--------+
              |                     |
              |                     |
              |       CometBFT      |
              |                     |
              |                     |
              +---------------------+
```

CometBFT只处理事务字节。它不知道这些字节是什么意思。CometBFT所做的只是对这些事务字节进行确定性排序。CometBFT通过ABCI将字节传递给应用程序，并期望返回代码通知它事务中包含的消息是否已成功处理.

以下是ABCI最重要的信息：

CheckTx：当CometBFT接收到一个事务时，它会被传递给应用程序，以检查是否满足一些基本要求。CheckTx用于保护完整节点的内存池免受垃圾邮件交易的影响。一个称为AnteHandler的特殊处理程序用于执行一系列验证步骤，如检查是否有足够的费用和验证签名。如果检查有效，则将事务添加到内存池并中继到对等节点。请注意，由于事务还没有被包括在块中，所以不使用CheckTx处理事务（即不发生状态修改）。

DeliverTx：当CometBFT接收到有效块时，块中的每个事务都会通过DeliverTx传递给应用程序以便进行处理。正是在这个阶段，状态转换才会发生。AnteHandler与事务中每个消息的实际Msg服务RPC一起再次执行。

BeginBlock/EndBlock：无论块是否包含事务，这些消息都在每个块的开头和结尾执行。触发逻辑的自动执行是很有用的。不过，请谨慎操作，因为计算成本高昂的循环可能会减慢区块链的速度，如果循环是无限的，甚至会冻结它。

##  state change 

```markdown
        -----------------------
        |Receive Block Proposal|
        -----------------------
                  |
              v
        -----------------------
        | BeginBlock          |
        -----------------------
                  |
              v
        -----------------------
        | DeliverTx(tx0)      |
        | DeliverTx(tx1)      |
        | DeliverTx(tx2)      |
        | DeliverTx(tx3)      |
        |   .         |
        |   .         |
        |   .         |
        -----------------------
                  |
              v
        -----------------------
        | EndBlock        |
        -----------------------
                  |
              v
        -----------------------
        | Consensus       |
        -----------------------
                  |
              v
        -----------------------
        | Commit          |
        -----------------------
```

