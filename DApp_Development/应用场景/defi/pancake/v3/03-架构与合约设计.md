# 死磕PancakeSwap V3（三）：架构与合约设计

> 本文是「死磕PancakeSwap V3」系列的第三篇，深入剖析V3的合约架构和核心数据结构设计。

## 系列导航

| 序号 | 标题 | 核心内容 |
|------|------|----------|
| 01 | PancakeSwap V3概述 | 发展历程、集中流动性、V3特色 |
| 02 | Tick机制与价格数学 | Tick设计、价格转换算法 |
| **03** | **架构与合约设计** | **Factory、Pool合约结构** |
| 04 | 交换机制深度解析 | swap函数、价格发现 |
| 05 | 流动性管理与头寸 | Position、mint/burn |
| 06 | 费用系统与预言机 | 费用分配、TWAP |
| 07 | V3与Uniswap V3对比 | 差异点、优化、适用场景 |
| 08 | 多链部署与特性适配 | BNB Chain、Ethereum、跨链策略 |
| 09 | 集成开发指南 | SDK使用、交易构建、最佳实践 |
| 10 | MEV与套利策略 | JIT、三明治攻击、防范策略 |

---

## 1. 整体架构概览

### 1.1 合约层次结构

PancakeSwap V3采用了模块化的架构设计，基于Uniswap V3架构进行了优化：

```mermaid
flowchart TB
    subgraph UserLayer["用户层"]
        U1[交易者]
        U2[流动性提供者]
    end

    subgraph PeripheryContracts["外围合约 Periphery Contracts"]
        R[SwapRouter]
        PM[NonfungiblePositionManager]
        Q[Quoter]
    end

    subgraph CoreContracts["核心合约 Core Contracts"]
        F[PancakeV3Factory]
        P1[Pool A]
        P2[Pool B]
        P3[Pool C]
    end

    subgraph Libraries["库合约 Libraries"]
        TM[TickMath]
        SM[SwapMath]
        POS[Position]
        TK[Tick]
        TB[TickBitmap]
        OR[Oracle]
    end

    U1 --> R
    U2 --> PM
    R --> P1 & P2 & P3
    PM --> P1 & P2 & P3
    F -->|创建| P1 & P2 & P3
    P1 & P2 & P3 --> TM & SM & POS & TK & TB & OR

    style CoreContracts fill:#ffeb3b
    style Libraries fill:#c8e6c9
```

### 1.2 核心设计原则

```mermaid
mindmap
  root((PancakeSwap V3<br/>架构设计))
    模块化
      接口分离
      库复用
      单一职责
    Gas优化
      存储槽打包
      位运算优化
      内联库函数
      BNB Chain优化
    安全性
      重入保护
      余额验证
      权限控制
    可扩展性
      工厂模式
      多费率支持
      预言机扩容
      多链适配
    社区治理
      DAO控制
      参数可调
      透明决策
```

---

## 2. Factory合约：单例工厂模式

### 2.1 工厂合约的职责

Factory合约是整个协议的入口点，负责池子的创建和参数管理：

```mermaid
flowchart LR
    subgraph FactoryDuties["Factory职责"]
        C1[创建Pool]
        C2[管理费率]
        C3[设置协议费]
        C4[所有权管理]
        C5[白名单管理]
    end

    subgraph KeyMappings["关键映射"]
        M1["getPool[token0][token1][fee]"]
        M2["feeAmountTickSpacing[fee]"]
    end

    C1 --> M1
    C2 --> M2

    style FactoryDuties fill:#ffeb3b
```

### 2.2 核心数据结构

```solidity
contract PancakeV3Factory is IPancakeV3Factory, PancakeV3PoolDeployer, NoDelegateCall {
    address public override owner;

    // 三层嵌套映射：确保每个代币对+费率只有一个池子
    mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;

    // 费率与Tick间距的绑定关系
    mapping(uint24 => int24) public override feeAmountTickSpacing;

    constructor() {
        owner = msg.sender;
        emit OwnerChanged(address(0), msg.sender);

        // PancakeSwap V3 预设费率等级
        feeAmountTickSpacing[100] = 1;     // 0.01% fee (stable pairs)
        feeAmountTickSpacing[500] = 10;    // 0.05% fee
        feeAmountTickSpacing[2500] = 50;   // 0.25% fee (PancakeSwap特色)
        feeAmountTickSpacing[10000] = 200;  // 1.00% fee
    }
}
```

### 2.3 PancakeSwap的费率特色

PancakeSwap V3提供了比Uniswap V3更丰富的费率选择：

| 费率 | 费用值(bps) | Tick间距 | 适用场景 |
|------|-------------|----------|----------|
| 0.01% | 100 | 1 | 稳定币对（USDT/USDC） |
| 0.05% | 500 | 10 | 相关资产（WBTC/renBTC） |
| 0.25% | 2500 | 50 | 主流币对（CAKE/BNB）|
| 1.00% | 10000 | 200 | 高风险/长尾资产 |

**0.25%费率的优势**：

```mermaid
graph LR
    subgraph PancakeSwap["PancakeSwap V3"]
        P1["0.25%费率"]
        P2["Tick间距50"]
        P3["中等精度"]
        P4["适合大多数主流币对"]
    end

    subgraph Uniswap["Uniswap V3"]
        U1["0.30%费率"]
        U2["Tick间距60"]
        U3["稍低精度"]
        U4["标准主流币对"]
    end

    P1 -->|"更灵活"| U1
    P2 -->|"更细"| U2

    style PancakeSwap fill:#ffeb3b
```

### 2.4 创建池子流程

```mermaid
flowchart TD
    A[用户发起createPool] --> B{tokenA < tokenB?}
    B -->|是| C[token0 = tokenA<br/>token1 = tokenB]
    B -->|否| D[token0 = tokenB<br/>token1 = tokenA]
    C --> E{费率有效?}
    D --> E
    E -->|否| F[回滚错误]
    E -->|是| G{池子已存在?}
    G -->|是| F
    G -->|否| H[部署Pool合约]
    H --> I[记录映射关系]
    I --> J[发射PoolCreated事件]
    J --> K[返回池子地址]

    style H fill:#ffeb3b
    style K fill:#c8e6c9
```

---

## 3. Pool合约：核心交易池

### 3.1 Pool合约的核心职责

```mermaid
mindmap
  root((PancakeV3Pool<br/>核心职责))
    状态管理
      slot0价格状态
      流动性跟踪
      Tick信息
    交易执行
      swap交换
      mint添加流动性
      burn移除流动性
      collect收取费用
    费用管理
      费用累积
      协议费分配
      手续费计算
    预言机功能
      价格观察
      TWAP计算
      历史数据
    事件日志
      Mint事件
      Burn事件
      Swap事件
      Collect事件
```

### 3.2 核心数据结构

```solidity
contract PancakeV3Pool is IPancakeV3Pool, NoDelegateCall {
    // 核心状态槽0：打包存储最常访问的数据
    struct Slot0 {
        uint160 sqrtPriceX96;     // 当前价格的平方根
        int24 tick;               // 当前tick
        uint16 observationIndex;  // 最新观察索引
        uint16 observationCardinality;  // 观察数
        uint16 observationCardinalityNext;  // 下一个观察数
        uint8 feeProtocol;       // 协议费率
        bool unlocked;           // 重入锁
    }

    Slot0 public override slot0;

    // 当前总流动性
    uint128 public override liquidity;

    // Tick信息映射
    mapping(int24 => Tick.Info) public override ticks;

    // 流动性头寸映射
    mapping(bytes32 => Position.Info) public override positions;

    // 预言机观察数据
    Observation[65535] public override observations;
}
```

### 3.3 Slot0结构优化

```mermaid
graph TB
    subgraph Slot0["Slot0结构 (256位)"]
        SP["sqrtPriceX96<br/>160位"]
        T["tick<br/>24位"]
        OI["observationIndex<br/>16位"]
        OC["observationCardinality<br/>16位"]
        OCN["observationCardinalityNext<br/>16位"]
        FP["feeProtocol<br/>8位"]
        UN["unlocked<br/>1位"]
        PAD["填充位<br/>15位"]
    end

    subgraph Optimization["优化效果"]
        O1["单个存储槽"]
        O2["减少gas消耗"]
        O3["提高读取速度"]
        O4["降低合约大小"]
    end

    Slot0 --> Optimization

    style Slot0 fill:#ffeb3b
```

### 3.4 Tick数据结构

```solidity
library Tick {
    struct Info {
        uint128 liquidityGross;           // 该tick的总流动性（添加+移除）
        int128 liquidityNet;              // 该tick的净流动性（添加-移除）
        uint256 feeGrowthOutside0X128;    // tick外部token0费用增长
        uint256 feeGrowthOutside1X128;    // tick外部token1费用增长
        int56 tickCumulativeOutside;      // tick外部累计tick值
        uint160 secondsPerLiquidityOutsideX128;  // tick外部流动性时间
        uint32 secondsOutside;            // tick外部时间
        bool initialized;                 // 是否已初始化
    }
}
```

### 3.5 Position数据结构

```solidity
library Position {
    struct Info {
        uint128 liquidity;              // 该头寸的流动性
        uint256 feeGrowthInside0LastX128;  // 最后记录的费用增长(token0)
        uint256 feeGrowthInside1LastX128;  // 最后记录的费用增长(token1)
        uint128 tokensOwed0;            // 待领取的token0数量
        uint128 tokensOwed1;            // 待领取的token1数量
    }
}
```

---

## 4. 核心库合约

### 4.1 TickMath库

```mermaid
graph LR
    subgraph TickMath["TickMath库"]
        F1["getSqrtRatioAtTick"]
        F2["getTickAtSqrtRatio"]
        F3["MIN_TICK/MAX_TICK"]
        F4["MIN_SQRT_RATIO/MAX_SQRT_RATIO"]
    end

    subgraph Usage["使用场景"]
        U1["价格转换"]
        U2["区间验证"]
        U3["边界检查"]
        U4["计算精度"]
    end

    TickMath --> Usage

    style TickMath fill:#ffeb3b
```

### 4.2 SwapMath库

```mermaid
graph LR
    subgraph SwapMath["SwapMath库"]
        F1["computeSwapStep"]
        F2["getGasCostOfMaxCrossedTicks"]
        F3["getFeeAmount"]
    end

    subgraph Usage["使用场景"]
        U1["计算交换步长"]
        U2["估算gas成本"]
        U3["计算交易费用"]
        U4["优化跨tick交换"]
    end

    SwapMath --> Usage

    style SwapMath fill:#ffeb3b
```

### 4.3 TickBitmap库

```mermaid
graph LR
    subgraph TickBitmap["TickBitmap库"]
        F1["flipTick"]
        F2["nextInitializedTickWithinOneWord"]
        F3["nextTickInSameWord"]
    end

    subgraph Purpose["目的"]
        P1["高效查找下一个tick"]
        P2["位运算优化存储"]
        P3["快速遍历区间"]
        P4["降低gas成本"]
    end

    TickBitmap --> Purpose

    style TickBitmap fill:#ffeb3b
```

**TickBitmap原理**：

```mermaid
graph TB
    subgraph Bitmap["Tick位图"]
        B0["Word 0<br/>ticks 0-255"]
        B1["Word 1<br/>ticks 256-511"]
        B2["Word 2<br/>ticks 512-767"]
        BN["Word N<br/>ticks N*256-(N+1)*256-1"]
    end

    subgraph Bit["单个位"]
        BT["1位 = 1个tick<br/>1=已初始化<br/>0=未初始化"]
    end

    subgraph Operation["位运算"]
        O1["OR: 设置位"]
        O2["AND: 查询位"]
        O3["SHR: 位移查找"]
    end

    Bitmap --> Bit
    Bit --> Operation

    style Bitmap fill:#ffeb3b
```

---

## 5. 外围合约设计

### 5.1 NonfungiblePositionManager

```mermaid
graph TB
    subgraph NFTPM["NonfungiblePositionManager"]
        F1["createPosition"]
        F2["increaseLiquidity"]
        F3["decreaseLiquidity"]
        F4["collect"]
        F5["burn"]
    end

    subgraph Benefits["优势"]
        B1["简化LP操作"]
        B2["NFT化管理"]
        B3["自动费用计算"]
        B4["用户体验优化"]
    end

    NFTPM --> Benefits

    style NFTPM fill:#ffeb3b
```

### 5.2 SwapRouter

```mermaid
graph LR
    subgraph Router["SwapRouter"]
        F1["exactInputSingle"]
        F2["exactInput"]
        F3["exactOutputSingle"]
        F4["exactOutput"]
    end

    subgraph Features["功能"]
        FT1["单池交换"]
        FT2["多池路由"]
        FT3["精确输入"]
        FT4["精确输出"]
    end

    Router --> Features

    style Router fill:#ffeb3b
```

---

## 6. PancakeSwap V3的架构优化

### 6.1 Gas优化策略

```mermaid
mindmap
  root((PancakeSwap V3<br/>Gas优化))
    存储优化
      Slot0打包
      紧凑数据结构
      映射优化
    计算优化
      位运算替代乘除
      预计算常量
      内联库函数
    操作优化
      批量操作支持
      重入保护优化
      事件精简
    BNB Chain优化
      低gas环境
      更快确认
      更低成本
```

### 6.2 多链适配

```mermaid
graph LR
    subgraph Chains["已部署链"]
        BSC[BNB Chain]
        ETH[Ethereum]
        APT[Aptos]
    end

    subgraph Adaptations["适配调整"]
        A1[Gas优化策略]
        A2[区块时间调整]
        A3[预言机配置]
        A4[费率层级]
    end

    Chains --> Adaptations

    style BSC fill:#ffeb3b
    style ETH fill:#e3f2fd
    style APT fill:#c8e6c9
```

---

## 7. 合约交互流程

### 7.1 创建池子流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant F as Factory
    participant P as Pool合约
    participant D as Deployer

    U->>F: createPool(tokenA, tokenB, fee)
    F->>F: 检查参数有效性
    F->>F: 地址排序
    F->>F: 检查费率等级
    F->>F: 检查池子是否已存在
    F->>D: deploy(参数)
    D->>P: 创建Pool合约实例
    P->>P: 初始化状态
    P->>F: 返回池子地址
    F->>F: 存储映射关系
    F->>F: 发射PoolCreated事件
    F-->>U: 返回池子地址
```

### 7.2 添加流动性流程

```mermaid
sequenceDiagram
    participant LP as LP
    participant PM as PositionManager
    participant P as Pool
    participant T as Tick

    LP->>PM: mint(参数)
    PM->>PM: 计算所需代币数量
    LP->>PM: transfer代币
    PM->>P: mint(流动性)
    P->>P: 更新流动性
    P->>P: 更新tick信息
    P->>T: 更新tick边界
    P->>PM: 返回结果
    PM->>PM: 创建NFT
    PM-->>LP: 返回tokenId
```

### 7.3 交易流程

```mermaid
sequenceDiagram
    participant T as 交易者
    participant R as Router
    participant P as Pool
    participant TB as TickBitmap

    T->>R: swap(参数)
    R->>P: swap(零地址, amount)
    P->>P: 检查重入锁
    P->>P: 计算价格影响
    loop 跨越多个tick
        P->>TB: 查找下一个tick
        TB-->>P: tick索引
        P->>P: 更新流动性
        P->>P: 更新价格
    end
    P->>P: 转移代币
    P->>P: 更新观察
    P->>P: 发射Swap事件
    P-->>R: 返回结果
    R-->>T: 返回结果
```

---

## 8. 本章小结

### 8.1 架构核心要点

```mermaid
mindmap
  root((PancakeSwap V3<br/>架构要点))
    Factory
      池子创建
      费率管理
      多费率支持
    Pool
      状态管理
      交易执行
      费用计算
      预言机功能
    Libraries
      TickMath
      SwapMath
      TickBitmap
      Position
    Periphery
      PositionManager
      SwapRouter
      Quoter
    优化
      Gas优化
      多链适配
      社区治理
```

### 8.2 关键数据结构速查

| 结构 | 位置 | 用途 |
|------|------|------|
| Slot0 | Pool | 核心状态（价格、tick等）|
| Position.Info | Pool | 流动性头寸信息 |
| Tick.Info | Pool | Tick级别数据 |
| Observation | Pool | 预言机观察数据 |

---

## 下一篇预告

在下一篇文章中，我们将深入探讨**V3与Uniswap V3对比**，包括：
- 架构差异对比
- 代码优化分析
- Gas效率对比
- 适用场景选择

---

## 参考资料

- [PancakeSwap V3 Core 源码](https://github.com/pancakeswap/pancake-v3-core)
- [PancakeSwap V3 Periphery 源码](https://github.com/pancakeswap/pancake-v3-periphery)
- [PancakeSwap V3 架构文档](https://docs.pancakeswap.finance/developers/smart-contracts/v3-contracts)
