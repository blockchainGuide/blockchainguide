# æ­»ç£•Uniswap V2ï¼ˆä¸ƒï¼‰ï¼šå®‰å…¨å®è·µä¸æœ€ä½³å®è·µ

> æœ¬æ–‡æ˜¯ã€Œæ­»ç£•Uniswap V2ã€ç³»åˆ—çš„ç¬¬ä¸ƒç¯‡ï¼Œå…¨é¢æ€»ç»“V2å¼€å‘ä¸­çš„å®‰å…¨å®è·µä¸æœ€ä½³å®è·µã€‚

## ç³»åˆ—å¯¼èˆª

| åºå· | æ ‡é¢˜ | æ ¸å¿ƒå†…å®¹ |
|:----:|------|----------|
| 01 | V2æ¦‚è¿°ä¸æ ¸å¿ƒåŸç† | æ’å®šä¹˜ç§¯AMMã€æ ¸å¿ƒå…¬å¼ |
| 02 | Factoryä¸Pairåˆçº¦ | åˆçº¦ç»“æ„ã€åˆ›å»ºæµç¨‹ |
| 03 | æµåŠ¨æ€§ä¸LPä»£å¸ | mint/burnã€ä»½é¢è®¡ç®— |
| 04 | äº¤æ¢æœºåˆ¶æ·±åº¦è§£æ | swapå‡½æ•°ã€æ»‘ç‚¹ã€Flash Swap |
| 05 | ä»·æ ¼é¢„è¨€æœº | TWAPã€ä»·æ ¼è®¡ç®— |
| 06 | Routerä¸è·¯ç”± | æœ€ä½³è·¯å¾„ã€å¤šè·³äº¤æ˜“ |
| **07** | **å®‰å…¨å®è·µä¸æœ€ä½³å®è·µ** | **æ¼æ´é˜²æŠ¤ã€å¼€å‘å»ºè®®** |

---

## 1. å®‰å…¨å¨èƒæ¦‚è§ˆ

### 1.1 å¸¸è§æ”»å‡»ç±»å‹

```mermaid
mindmap
  root((V2å®‰å…¨å¨èƒ))
    ä»·æ ¼æ“çºµ
      é—ªç”µè´·æ”»å‡»
      ä¸‰æ˜æ²»æ”»å‡»
      æ´—ç›˜äº¤æ˜“
    é‡å…¥æ”»å‡»
      swapé‡å…¥
      callbacké‡å…¥
    æ»‘ç‚¹æ”»å‡»
      å‰ç«¯äº¤æ˜“
      æŠ¢è·‘äº¤æ˜“
    é¢„è¨€æœºæ”»å‡»
      TWAPæ“çºµ
      çŸ­æœŸæ“çºµ
    æˆæƒé£é™©
      æ— é™æˆæƒ
      æ¶æ„åˆçº¦
```

### 1.2 æ”»å‡»å½±å“

```mermaid
graph TB
    subgraph Attacks[\"æ”»å‡»ç±»å‹\"]
        A1[\"ä»·æ ¼æ“çºµ\"]
        A2[\"MEVæ”»å‡»\"]
        A3[\"é‡å…¥æ”»å‡»\"]
        A4[\"æˆæƒç›—ç”¨\"]
    end

    subgraph Impact[\"æ½œåœ¨å½±å“\"]
        I1[\"èµ„é‡‘æŸå¤±\"]
        I2[\"ä»·æ ¼åç¦»\"]
        I3[\"å¥—åˆ©æµå¤±\"]
        I4[\"ç”¨æˆ·ä¿¡ä»»ä¸‹é™\"]
    end

    Attacks --> Impact

    style I1 fill:#ffcdd2
    style I4 fill:#ffcdd2
```

---

## 2. æ»‘ç‚¹ä¿æŠ¤

### 2.1 æ»‘ç‚¹æ”»å‡»åŸç†

```mermaid
sequenceDiagram
    participant M as çŸ¿å·¥/æ”»å‡»è€…
    participant U as ç”¨æˆ·
    participant P as Pairåˆçº¦
    participant Mempool as å†…å­˜æ± 

    U->>Mempool: æäº¤äº¤æ˜“: swap(1000 ETH, amountOutMin=1900 USDC)
    M->>Mempool: ç›‘æµ‹åˆ°é«˜ä»·å€¼äº¤æ˜“

    Note over M: åœ¨ç”¨æˆ·äº¤æ˜“ä¹‹å‰æ’å…¥äº¤æ˜“

    M->>P: æŠ¢è·‘äº¤æ˜“: swap(100 ETH, 195 USDC)
    P->>M: ä»·æ ¼æ»‘ç‚¹

    M->>Mempool: ç”¨æˆ·äº¤æ˜“æ‰§è¡Œ
    Note over U: ç”¨æˆ·è·å¾—æ›´å·®çš„ä»·æ ¼

    M->>P: å›è·‘äº¤æ˜“: swap(195 USDC, 99 ETH)
    M->>M: è·å¾—çº¦4 ETHåˆ©æ¶¦
```

### 2.2 æ»‘ç‚¹ä¿æŠ¤å®ç°

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

contract SlippageProtectedTrader {
    IUniswapV2Router02 public immutable router;

    struct SwapParams {
        uint256 amountIn;
        uint256 slippageTolerance; // åŸºç‚¹ï¼Œå¦‚ 300 = 3%
        address[] path;
        address recipient;
    }

    event SwapExecuted(
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 amountIn,
        uint256 amountOut,
        uint256 slippage
    );

    constructor(address _router) {
        router = IUniswapV2Router02(_router);
    }

    /// @notice å¸¦æ»‘ç‚¹ä¿æŠ¤çš„äº¤æ¢
    function swapWithProtection(SwapParams calldata params)
        external
        returns (uint256 amountOut)
    {
        // 1. æŸ¥è¯¢é¢„æœŸè¾“å‡º
        uint256[] memory expectedAmounts = router.getAmountsOut(
            params.amountIn,
            params.path
        );

        uint256 expectedAmountOut = expectedAmounts[expectedAmounts.length - 1];

        // 2. è®¡ç®—æœ€å°è¾“å‡º
        uint256 amountOutMin = (expectedAmountOut * (10000 - params.slippageTolerance)) / 10000;

        // 3. éªŒè¯æ»‘ç‚¹è®¾ç½®åˆç†
        require(
            params.slippageTolerance <= 1000, // æœ€å¤š10%
            "Slippage too high"
        );

        require(
            params.slippageTolerance >= 10, // æœ€å°‘0.1%
            "Slippage too low"
        );

        // 4. æˆæƒRouter
        IERC20(params.path[0]).approve(address(router), params.amountIn);

        // 5. æ‰§è¡Œäº¤æ˜“
        uint256[] memory amounts = router.swapExactTokensForTokens(
            params.amountIn,
            amountOutMin,
            params.path,
            params.recipient,
            block.timestamp
        );

        amountOut = amounts[amounts.length - 1];

        // 6. è®¡ç®—å®é™…æ»‘ç‚¹
        uint256 actualSlippage = expectedAmountOut > amountOut
            ? ((expectedAmountOut - amountOut) * 10000) / expectedAmountOut
            : 0;

        emit SwapExecuted(
            params.path[0],
            params.path[params.path.length - 1],
            params.amountIn,
            amountOut,
            actualSlippage
        );
    }

    /// @notice æ‰¹é‡äº¤æ˜“å¸¦æ»‘ç‚¹ä¿æŠ¤
    function batchSwapWithProtection(
        SwapParams[] calldata paramsList
    ) external returns (uint256[] memory amountsOut) {
        amountsOut = new uint256[](paramsList.length);

        for (uint256 i = 0; i < paramsList.length; i++) {
            amountsOut[i] = this.swapWithProtection(paramsList[i]);
        }
    }

    /// @notice åŠ¨æ€æ»‘ç‚¹è®¡ç®—ï¼ˆæ ¹æ®æ³¢åŠ¨ç‡ï¼‰
    function calculateDynamicSlippage(
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) external view returns (uint256 recommendedSlippage) {
        // è·å–å‚¨å¤‡é‡
        address pair = _getPairAddress(tokenIn, tokenOut);
        (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(pair).getReserves();

        // è®¡ç®—äº¤æ˜“è§„æ¨¡å å‚¨å¤‡çš„æ¯”ä¾‹
        (uint256 reserveIn, uint256 reserveOut) = tokenIn < tokenOut
            ? (reserve0, reserve1)
            : (reserve1, reserve0);

        uint256 tradeRatio = (amountIn * 10000) / reserveIn;

        // æ ¹æ®äº¤æ˜“è§„æ¨¡åŠ¨æ€è°ƒæ•´æ»‘ç‚¹å®¹å¿åº¦
        if (tradeRatio < 10) { // å°äº0.1%
            recommendedSlippage = 30; // 0.3%
        } else if (tradeRatio < 100) { // 0.1% - 1%
            recommendedSlippage = 100; // 1%
        } else if (tradeRatio < 500) { // 1% - 5%
            recommendedSlippage = 300; // 3%
        } else { // å¤§äº5%
            recommendedSlippage = 500; // 5%
        }
    }

    function _getPairAddress(address tokenA, address tokenB)
        internal
        view
        returns (address)
    {
        return IUniswapV2Factory(router.factory()).getPair(tokenA, tokenB);
    }
}
```

### 2.3 äº¤æ˜“ deadline ä¿æŠ¤

```solidity
contract DeadlineProtectedTrader {
    uint256 public constant MAX_DEADLINE_BUFFER = 1 hours;

    /// @notice å¸¦deadlineçš„äº¤æ¢
    function swapWithDeadline(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address recipient,
        uint256 deadline
    ) external returns (uint256[] memory amounts) {
        // 1. éªŒè¯deadline
        require(
            deadline > block.timestamp,
            "Deadline must be in future"
        );

        require(
            deadline <= block.timestamp + MAX_DEADLINE_BUFFER,
            "Deadline too far"
        );

        // 2. æ‰§è¡Œäº¤æ˜“
        // ...
    }

    /// @notice è‡ªåŠ¨è®¡ç®—åˆç†çš„deadline
    function getReasonableDeadline(uint256 extraTime)
        external
        view
        returns (uint256)
    {
        require(
            extraTime <= MAX_DEADLINE_BUFFER,
            "Extra time too large"
        );

        return block.timestamp + extraTime;
    }
}
```

---

## 3. é‡å…¥æ”»å‡»é˜²æŠ¤

### 3.1 é‡å…¥æ”»å‡»åŸç†

```mermaid
stateDiagram-v2
    [*] --> Normal: æ­£å¸¸swap
    Normal --> Callback: uniswapV2Call
    Callback --> Reenter: æ¶æ„åˆçº¦å†æ¬¡è°ƒç”¨swap
    Reenter --> Exploit: ç ´åçŠ¶æ€ä¸€è‡´æ€§
    Exploit --> [*]: èµ„é‡‘è¢«ç›—

    Callback --> Normal: æ­£å¸¸è¿”å›
    Normal --> [*]: äº¤æ˜“å®Œæˆ
```

### 3.2 Checks-Effects-Interactions æ¨¡å¼

```solidity
contract SecureSwapContract {
    using SafeERC20 for IERC20;

    uint256 private locked = 1;

    modifier lock() {
        require(locked == 1, "Reentrancy detected");
        locked = 0;
        _;
        locked = 1;
    }

    mapping(address => uint256) public userBalances;

    /// @notice æ­£ç¡®çš„äº¤æ¢æ¨¡å¼
    function swapAndDeposit(
        uint256 amountIn,
        address[] calldata path,
        address recipient
    ) external lock {
        // 1. CHECKS: éªŒè¯è¾“å…¥
        require(path.length >= 2, "Invalid path");
        require(amountIn > 0, "Invalid amount");

        // 2. EFFECTS: æ›´æ–°çŠ¶æ€
        uint256 oldBalance = userBalances[recipient];

        // 3. INTERACTIONS: å¤–éƒ¨è°ƒç”¨
        IERC20(path[0]).safeTransferFrom(msg.sender, address(this), amountIn);
        IERC20(path[0]).safeApprove(address(router), amountIn);

        uint256[] memory amounts = router.swapExactTokensForTokens(
            amountIn,
            0,
            path,
            address(this),
            block.timestamp
        );

        // 4. å†æ¬¡æ›´æ–°çŠ¶æ€ï¼ˆåœ¨æ‰€æœ‰å¤–éƒ¨è°ƒç”¨ä¹‹åï¼‰
        userBalances[recipient] = oldBalance + amounts[amounts.length - 1];

        // 5. æœ€åè½¬è´¦ç»™ç”¨æˆ·
        IERC20(path[path.length - 1]).safeTransfer(
            recipient,
            amounts[amounts.length - 1]
        );
    }
}
```

### 3.3 Reentrancy Guard

```solidity
contract ReentrancyGuard {
    uint256 private locked = 1;

    modifier noReentrancy() {
        require(locked == 1, "Reentrancy detected");
        locked = 0;
        _;
        locked = 1;
    }

    // ä½¿ç”¨ç¤ºä¾‹
    function vulnerableFunction() external noReentrancy {
        // å®‰å…¨çš„ä»£ç 
    }
}
```

---

## 4. ä»·æ ¼æ“çºµé˜²æŠ¤

### 4.1 TWAP å®‰å…¨ä½¿ç”¨

```solidity
contract PriceManipulationResistant {
    AdvancedTWAPOracle public oracle;

    uint256 public constant MIN_TWAP_PERIOD = 1 hours;
    uint256 public constant MAX_PRICE_DEVIATION = 300; // 3%

    struct PriceCheck {
        uint256 twapPrice;
        uint256 spotPrice;
        uint256 timestamp;
        bool valid;
    }

    mapping(address => PriceCheck) public priceChecks;

    /// @notice å®‰å…¨çš„ä»·æ ¼æŸ¥è¯¢
    function getSafePrice(
        address tokenIn,
        address tokenOut
    ) external returns (uint256 price) {
        // 1. è·å–TWAPä»·æ ¼
        (uint256 twapPrice, ) = oracle.consult(
            _getPair(tokenIn, tokenOut),
            MIN_TWAP_PERIOD
        );

        // 2. è·å–å³æ—¶ä»·æ ¼
        (uint256 spotPrice, ) = oracle.spotPrice(
            _getPair(tokenIn, tokenOut)
        );

        // 3. è®¡ç®—åå·®
        uint256 deviation = _calculateDeviation(spotPrice, twapPrice);

        // 4. å¦‚æœåå·®è¿‡å¤§ï¼Œä½¿ç”¨TWAPä»·æ ¼
        if (deviation > MAX_PRICE_DEVIATION) {
            emit PriceAnomaly Detected(tokenIn, tokenOut, twapPrice, spotPrice, deviation);
            price = twapPrice;
        } else {
            // å¯ä»¥ä½¿ç”¨ä¸¤è€…çš„åŠ æƒå¹³å‡
            price = (twapPrice * 7 + spotPrice * 3) / 10;
        }

        // 5. è®°å½•ä»·æ ¼æ£€æŸ¥
        priceChecks[tokenIn] = PriceCheck({
            twapPrice: twapPrice,
            spotPrice: spotPrice,
            timestamp: block.timestamp,
            valid: true
        });

        return price;
    }

    function _calculateDeviation(
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 deviationBps) {
        if (value1 > value2) {
            deviationBps = ((value1 - value2) * 10000) / value2;
        } else {
            deviationBps = ((value2 - value1) * 10000) / value2;
        }
    }

    function _getPair(address tokenA, address tokenB)
        internal
        view
        returns (address)
    {
        return IUniswapV2Factory(factory).getPair(tokenA, tokenB);
    }

    event PriceAnomalyDetected(
        address indexed tokenIn,
        address indexed tokenOut,
        uint256 twapPrice,
        uint256 spotPrice,
        uint256 deviation
    );
}
```

### 4.2 å¤šæ•°æ®æºéªŒè¯

```solidity
contract MultiSourceOracle {
    struct PriceSource {
        address pair;
        uint256 weight; // æƒé‡
        bool enabled;
    }

    mapping(address => PriceSource[]) public priceSources;

    /// @notice æ·»åŠ ä»·æ ¼æº
    function addPriceSource(
        address token,
        address pair,
        uint256 weight
    ) external onlyOwner {
        require(weight <= 100, "Weight too high");
        priceSources[token].push(PriceSource({
            pair: pair,
            weight: weight,
            enabled: true
        }));
    }

    /// @notice è·å–åŠ æƒå¹³å‡ä»·æ ¼
    function getWeightedPrice(address token)
        external
        view
        returns (uint256 weightedPrice)
    {
        uint256 totalWeight;
        uint256 weightedSum;

        PriceSource[] memory sources = priceSources[token];

        for (uint256 i = 0; i < sources.length; i++) {
            if (!sources[i].enabled) continue;

            (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(sources[i].pair).getReserves();

            uint256 price;
            if (token < IUniswapV2Pair(sources[i].pair).token1()) {
                price = (uint256(reserve1) * 1e18) / reserve0;
            } else {
                price = (uint256(reserve0) * 1e18) / reserve1;
            }

            weightedSum += price * sources[i].weight;
            totalWeight += sources[i].weight;
        }

        require(totalWeight > 0, "No enabled sources");
        weightedPrice = weightedSum / totalWeight;
    }
}
```

---

## 5. æˆæƒå®‰å…¨

### 5.1 æˆæƒæœ€ä½³å®è·µ

```mermaid
graph TB
    subgraph Approvals[\"æˆæƒç­–ç•¥\"]
        A1[\"ç²¾ç¡®æˆæƒ<br/>æ¨è\"]
        A2[\"æ— é™æˆæƒ<br/>ä»…å¯ä¿¡DApp\"]
        A3[\"å–æ¶ˆæˆæƒ<br/>ä¸å†ä½¿ç”¨æ—¶\"]
    end

    subgraph Risks[\"é£é™©ç­‰çº§\"]
        R1[\"ç²¾ç¡®æˆæƒ: ä½\"]
        R2[\"æ— é™æˆæƒ: é«˜\"]
    end

    Approvals --> Risks

    style A1 fill:#c8e6c9
    style A2 fill:#ffcdd2
```

### 5.2 å®‰å…¨æˆæƒç®¡ç†å™¨

```solidity
contract SafeApprovalManager {
    mapping(address => mapping(address => uint256)) public approvals;

    event ApprovalSet(
        address indexed owner,
        address indexed spender,
        uint256 amount
    );

    /// @notice è®¾ç½®ç²¾ç¡®æˆæƒ
    function setApproval(
        address token,
        address spender,
        uint256 amount
    ) external {
        IERC20(token).approve(spender, 0); // å…ˆæ¸…é™¤
        IERC20(token).approve(spender, amount);

        approvals[msg.sender][spender] = amount;

        emit ApprovalSet(msg.sender, spender, amount);
    }

    /// @notice å¢é‡æˆæƒ
    function increaseApproval(
        address token,
        address spender,
        uint256 addedValue
    ) external {
        uint256 currentApproval = IERC20(token).allowance(msg.sender, spender);

        IERC20(token).approve(spender, currentApproval + addedValue);
        approvals[msg.sender][spender] = currentApproval + addedValue;

        emit ApprovalSet(msg.sender, spender, currentApproval + addedValue);
    }

    /// @notice å‡é‡æˆæƒ
    function decreaseApproval(
        address token,
        address spender,
        uint256 subtractedValue
    ) external {
        uint256 currentApproval = IERC20(token).allowance(msg.sender, spender);

        uint256 newApproval = currentApproval > subtractedValue
            ? currentApproval - subtractedValue
            : 0;

        IERC20(token).approve(spender, newApproval);
        approvals[msg.sender][spender] = newApproval;

        emit ApprovalSet(msg.sender, spender, newApproval);
    }

    /// @notice æ’¤é”€æ‰€æœ‰æˆæƒ
    function revokeAllApprovals(address token, address spender) external {
        IERC20(token).approve(spender, 0);
        approvals[msg.sender][spender] = 0;

        emit ApprovalSet(msg.sender, spender, 0);
    }

    /// @notice æ‰¹é‡æ’¤é”€æˆæƒ
    function revokeBatchApprovals(
        address[] calldata tokens,
        address[] calldata spenders
    ) external {
        require(tokens.length == spenders.length, "Length mismatch");

        for (uint256 i = 0; i < tokens.length; i++) {
            IERC20(tokens[i]).approve(spenders[i], 0);
            approvals[msg.sender][spenders[i]] = 0;

            emit ApprovalSet(msg.sender, spenders[i], 0);
        }
    }
}
```

### 5.3 Permit (EIP-2612) æ”¯æŒ

```solidity
contract PermitTrader {
    /// @notice ä½¿ç”¨Permitè¿›è¡Œæ— æˆæƒäº¤æ˜“
    function swapWithPermit(
        address token,
        uint256 amount,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s,
        address[] calldata path,
        address recipient
    ) external returns (uint256[] memory amounts) {
        // 1. æ‰§è¡ŒPermitç­¾åéªŒè¯å¹¶æˆæƒ
        IERC20Permit(token).permit(
            msg.sender,
            address(this),
            amount,
            deadline,
            v,
            r,
            s
        );

        // 2. è½¬å…¥ä»£å¸
        IERC20(token).transferFrom(msg.sender, address(this), amount);

        // 3. æ‰§è¡Œäº¤æ˜“
        IERC20(token).approve(address(router), amount);

        amounts = router.swapExactTokensForTokens(
            amount,
            0,
            path,
            recipient,
            block.timestamp
        );
    }
}
```

---

## 6. MEV é˜²æŠ¤ç­–ç•¥

### 6.1 MEV æ”»å‡»ç±»å‹

```mermaid
mindmap
  root((MEVæ”»å‡»))
    æŠ¢è·‘
      å¤åˆ¶äº¤æ˜“å‚æ•°
      æé«˜gasä»·æ ¼
      ä¼˜å…ˆæ‰§è¡Œ
    å›è·‘
      è§‚å¯Ÿäº¤æ˜“ç»“æœ
      åœ¨ä¹‹åæ‰§è¡Œ
      ä»ä»·æ ¼å˜åŒ–è·åˆ©
    ä¸‰æ˜æ²»
      æŠ¢è·‘+å›è·‘ç»„åˆ
      åŒå‘å‰¥å‰Šç”¨æˆ·
    å¥—åˆ©
      åˆ©ç”¨ä»·æ ¼å·®å¼‚
      è·¨DEXå¥—åˆ©
```

### 6.2 ç§æœ‰å†…å­˜æ± æ–¹æ¡ˆ

```solidity
concept[\"ç§æœ‰å†…å­˜æ± æ–¹æ¡ˆ\"] {
    // æ³¨æ„ï¼šè¿™æ˜¯æ¦‚å¿µæ€§ä»£ç ï¼Œå®é™…éœ€è¦ä¸ç§æœ‰å†…å­˜æ± æœåŠ¡é›†æˆ

    contract PrivateMempoolTrader {
        address public trustedRelayer;

        constructor(address _trustedRelayer) {
            trustedRelayer = _trustedRelayer;
        }

        modifier onlyTrusted() {
            require(msg.sender == trustedRelayer, "Not trusted relayer");
            _;
        }

        // é€šè¿‡å¯ä¿¡ä¸­ç»§å™¨æäº¤äº¤æ˜“
        function submitPrivateSwap(
            uint256 amountIn,
            address[] calldata path,
            bytes calldata encodedCall
        ) external onlyTrusted {
            // ç›´æ¥æ‰§è¡Œï¼Œä¸ç»è¿‡å…¬å…±å†…å­˜æ± 
            (bool success, ) = address(router).call(encodedCall);
            require(success, "Swap failed");
        }
    }
}
```

### 6.3 æ—¶é—´å¹³å‡æ‰§è¡Œ

```solidity
contract TimeAveragedTrader {
    struct TradePlan {
        uint256 totalAmount;
        uint256 numTranches;
        uint256 interval;
        uint256 executedTranches;
        uint256 lastExecutionTime;
        address[] path;
        address recipient;
    }

    mapping(bytes32 => TradePlan) public tradePlans;

    event TradePlanCreated(bytes32 indexed planId, uint256 totalAmount, uint256 numTranches);
    event TradeExecuted(bytes32 indexed planId, uint256 trancheAmount);

    /// @notice åˆ›å»ºæ—¶é—´å¹³å‡äº¤æ˜“è®¡åˆ’
    function createTradePlan(
        uint256 totalAmount,
        uint256 numTranches,
        uint256 interval,
        address[] calldata path,
        address recipient
    ) external returns (bytes32) {
        require(numTranches > 0, "Invalid tranches");
        require(interval >= 1 hours, "Interval too short");

        bytes32 planId = keccak256(abi.encodePacked(
            msg.sender,
            block.timestamp,
            totalAmount
        ));

        tradePlans[planId] = TradePlan({
            totalAmount: totalAmount,
            numTranches: numTranches,
            interval: interval,
            executedTranches: 0,
            lastExecutionTime: 0,
            path: path,
            recipient: recipient
        });

        emit TradePlanCreated(planId, totalAmount, numTranches);

        return planId;
    }

    /// @notice æ‰§è¡Œè®¡åˆ’çš„ä¸‹ä¸€ç¬”äº¤æ˜“
    function executeNextTranche(bytes32 planId) external {
        TradePlan storage plan = tradePlans[planId];

        require(plan.executedTranches < plan.numTranches, "Plan completed");
        require(
            block.timestamp >= plan.lastExecutionTime + plan.interval,
            "Too early"
        );

        // è®¡ç®—æœ¬ç¬”äº¤æ˜“æ•°é‡
        uint256 trancheAmount = plan.totalAmount / plan.numTranches;
        uint256 remainingAmount = plan.totalAmount - (plan.totalAmount / plan.numTranches) * plan.executedTranches;

        // æœ€åä¸€ç¬”ä½¿ç”¨å‰©ä½™å…¨éƒ¨
        if (plan.executedTranches == plan.numTranches - 1) {
            trancheAmount = remainingAmount;
        }

        // æ‰§è¡Œäº¤æ˜“
        IERC20(plan.path[0]).transferFrom(msg.sender, address(this), trancheAmount);
        IERC20(plan.path[0]).approve(address(router), trancheAmount);

        router.swapExactTokensForTokens(
            trancheAmount,
            0,
            plan.path,
            plan.recipient,
            block.timestamp
        );

        plan.executedTranches++;
        plan.lastExecutionTime = block.timestamp;

        emit TradeExecuted(planId, trancheAmount);
    }
}
```

---

## 7. å®‰å…¨å®¡è®¡æ£€æŸ¥æ¸…å•

### 7.1 åˆçº¦çº§åˆ«æ£€æŸ¥

```mermaid
mindmap
  root((å®‰å…¨å®¡è®¡))
    è®¿é—®æ§åˆ¶
      onlyOwneræ£€æŸ¥
      è§’è‰²æƒé™åˆ’åˆ†
      ç´§æ€¥æš‚åœæœºåˆ¶
    çŠ¶æ€ç®¡ç†
      é‡å…¥ä¿æŠ¤
      æ•´æ•°æº¢å‡ºæ£€æŸ¥
      çŠ¶æ€ä¸€è‡´æ€§
    å¤–éƒ¨è°ƒç”¨
      Checks-Effects-Interactions
      ä½çº§è°ƒç”¨å®‰å…¨
      é”™è¯¯å¤„ç†
    ä¸šåŠ¡é€»è¾‘
      æ»‘ç‚¹ä¿æŠ¤
      deadlineéªŒè¯
      ä»·æ ¼æºéªŒè¯
```

### 7.2 å®¡è®¡æ£€æŸ¥æ¸…å•

```solidity
contract SecurityAuditChecklist {
    // ============================================
    // 1. è®¿é—®æ§åˆ¶æ£€æŸ¥
    // ============================================

    address public owner;
    mapping(address => bool) public admins;

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier onlyAdmin() {
        require(admins[msg.sender], "Not admin");
        _;
    }

    // âœ… CHECK: æ‰€æœ‰æ•æ„Ÿå‡½æ•°éƒ½æœ‰è®¿é—®æ§åˆ¶
    function sensitiveFunction() external onlyOwner {
        // æ•æ„Ÿæ“ä½œ
    }

    // ============================================
    // 2. é‡å…¥ä¿æŠ¤æ£€æŸ¥
    // ============================================

    uint256 private locked = 1;

    modifier noReentrancy() {
        require(locked == 1, "Reentrancy detected");
        locked = 0;
        _;
        locked = 1;
    }

    // âœ… CHECK: çŠ¶æ€å˜æ›´å‡½æ•°æœ‰é‡å…¥ä¿æŠ¤
    function stateChangingFunction() external noReentrancy {
        // çŠ¶æ€å˜æ›´æ“ä½œ
    }

    // ============================================
    // 3. æ»‘ç‚¹ä¿æŠ¤æ£€æŸ¥
    // ============================================

    // âœ… CHECK: æ‰€æœ‰äº¤æ¢å‡½æ•°éƒ½æœ‰æ»‘ç‚¹ä¿æŠ¤
    function swapWithSlippageProtection(
        uint256 amountIn,
        uint256 minAmountOut
    ) external {
        require(minAmountOut > 0, "Invalid min output");
        require(minAmountOut <= amountIn, "Invalid slippage");

        // æ‰§è¡Œäº¤æ¢...
    }

    // ============================================
    // 4. Deadlineæ£€æŸ¥
    // ============================================

    // âœ… CHECK: æ‰€æœ‰äº¤æ¢å‡½æ•°éƒ½æœ‰deadline
    function swapWithDeadline(
        uint256 deadline
    ) external {
        require(deadline >= block.timestamp, "Deadline expired");
        require(deadline <= block.timestamp + 1 hours, "Deadline too far");

        // æ‰§è¡Œäº¤æ¢...
    }

    // ============================================
    // 5. å®‰å…¨çš„æ•°å­¦è¿ç®—
    // ============================================

    // âœ… CHECK: ä½¿ç”¨Solidity 0.8+çš„å†…ç½®æº¢å‡ºæ£€æŸ¥
    // æˆ–è€…ä½¿ç”¨SafeMathåº“

    function safeMath(uint256 a, uint256 b) external pure returns (uint256) {
        return a + b; // Solidity 0.8+ è‡ªåŠ¨æ£€æŸ¥æº¢å‡º
    }

    // ============================================
    // 6. å®‰å…¨çš„å¤–éƒ¨è°ƒç”¨
    // ============================================

    // âœ… CHECK: ä½¿ç”¨Checks-Effects-Interactionsæ¨¡å¼
    function safeExternalCall(address target, bytes memory data)
        external
        noReentrancy
    {
        // 1. Checks
        require(target != address(0), "Invalid target");

        // 2. Effects (æ›´æ–°çŠ¶æ€)
        // ...

        // 3. Interactions (å¤–éƒ¨è°ƒç”¨)
        (bool success, bytes memory result) = target.call(data);
        require(success, "External call failed");
    }

    // ============================================
    // 7. ç´§æ€¥æš‚åœæœºåˆ¶
    // ============================================

    bool public paused;

    modifier whenNotPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    function pause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }

    // âœ… CHECK: å…³é”®å‡½æ•°æœ‰æš‚åœä¿æŠ¤
    function criticalFunction() external whenNotPaused {
        // å…³é”®æ“ä½œ
    }

    // ============================================
    // 8. äº‹ä»¶æ—¥å¿—
    // ============================================

    // âœ… CHECK: æ‰€æœ‰æ•æ„Ÿæ“ä½œéƒ½æœ‰äº‹ä»¶æ—¥å¿—
    event SensitiveAction(
        address indexed user,
        uint256 value,
        uint256 timestamp
    );

    function sensitiveAction(uint256 value) external {
        // æ‰§è¡Œæ“ä½œ
        emit SensitiveAction(msg.sender, value, block.timestamp);
    }
}
```

---

## 8. å¼€å‘æœ€ä½³å®è·µ

### 8.1 é¡¹ç›®ç»“æ„

```
uniswap-v2-integration/
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”œâ”€â”€ IUniswapV2Factory.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV2Pair.sol
â”‚   â”‚   â”œâ”€â”€ IUniswapV2Router02.sol
â”‚   â”‚   â””â”€â”€ IERC20Permit.sol
â”‚   â”œâ”€â”€ libraries/
â”‚   â”‚   â”œâ”€â”€ UniswapV2Library.sol
â”‚   â”‚   â””â”€â”€ SafeERC20.sol
â”‚   â”œâ”€â”€ routers/
â”‚   â”‚   â””â”€â”€ OptimalRouter.sol
â”‚   â””â”€â”€ oracles/
â”‚       â””â”€â”€ SafeOracle.sol
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ security/
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ deploy/
â””â”€â”€ README.md
```

### 8.2 æµ‹è¯•ç­–ç•¥

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

contract UniswapV2SecurityTest is Test {
    IUniswapV2Router02 router;
    IUniswapV2Factory factory;
    IUniswapV2Pair pair;

    address tokenA;
    address tokenB;
    address attacker;

    function setUp() public {
        // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
        router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        factory = IUniswapV2Factory(router.factory());

        tokenA = address(new TestToken("TokenA", "TA", 18));
        tokenB = address(new TestToken("TokenB", "TB", 18));

        attacker = address(0x1337);
    }

    // ============================================
    // å®‰å…¨æµ‹è¯•ç”¨ä¾‹
    // ============================================

    function testReentrancyProtection() public {
        // æµ‹è¯•é‡å…¥ä¿æŠ¤
    }

    function testSlippageProtection() public {
        // æµ‹è¯•æ»‘ç‚¹ä¿æŠ¤
    }

    function testFlashLoanAttack() public {
        // æµ‹è¯•é—ªç”µè´·æ”»å‡»é˜²æŠ¤
    }

    function testPriceManipulation() public {
        // æµ‹è¯•ä»·æ ¼æ“çºµé˜²æŠ¤
    }

    function testMaxApprovalRisk() public {
        // æµ‹è¯•æ— é™æˆæƒé£é™©
    }
}
```

### 8.3 éƒ¨ç½²éªŒè¯

```solidity
// deployment verification script

function verifyDeployment(address routerAddress) external view returns (bool) {
    IUniswapV2Router02 router = IUniswapV2Router02(routerAddress);

    // 1. éªŒè¯Factoryåœ°å€
    require(router.factory() != address(0), "Invalid factory");

    // 2. éªŒè¯WETHåœ°å€
    require(router.WETH() != address(0), "Invalid WETH");

    // 3. éªŒè¯Routeræ¥å£
    try router.factory() {
        // Factoryè°ƒç”¨æˆåŠŸ
    } catch {
        revert("Router interface invalid");
    }

    return true;
}
```

---

## 9. æœ¬ç« å°ç»“

### 9.1 å®‰å…¨å®è·µæ€»ç»“

```mermaid
mindmap
  root((V2å®‰å…¨å®è·µ))
    æ»‘ç‚¹ä¿æŠ¤
      è®¾ç½®æœ€å°è¾“å‡º
      åˆç†å®¹å¿åº¦
      deadlineéªŒè¯
    é‡å…¥é˜²æŠ¤
      lock modifier
      CEIæ¨¡å¼
      çŠ¶æ€æ›´æ–°åœ¨å¤–éƒ¨è°ƒç”¨å‰
    ä»·æ ¼å®‰å…¨
      ä½¿ç”¨TWAP
      å¤šæ•°æ®æºéªŒè¯
      åå·®æ£€æµ‹
    æˆæƒç®¡ç†
      ç²¾ç¡®æˆæƒ
      Permitæ”¯æŒ
      å®šæœŸæ’¤é”€
    MEVé˜²æŠ¤
      ç§æœ‰å†…å­˜æ± 
      æ—¶é—´å¹³å‡æ‰§è¡Œ
      éšæœºç­–ç•¥
```

### 9.2 å®‰å…¨å»ºè®®æ¸…å•

| ç±»åˆ« | å»ºè®® | ä¼˜å…ˆçº§ |
|------|------|--------|
| **æ»‘ç‚¹** | å§‹ç»ˆè®¾ç½®amountOutMin | ğŸ”´ é«˜ |
| **Deadline** | è®¾ç½®åˆç†çš„deadline | ğŸ”´ é«˜ |
| **æˆæƒ** | é¿å…æ— é™æˆæƒ | ğŸŸ¡ ä¸­ |
| **æµ‹è¯•** | ç¼–å†™å®Œæ•´æµ‹è¯•ç”¨ä¾‹ | ğŸ”´ é«˜ |
| **å®¡è®¡** | ç¬¬ä¸‰æ–¹å®‰å…¨å®¡è®¡ | ğŸ”´ é«˜ |
| **é‡å…¥** | ä½¿ç”¨ReentrancyGuard | ğŸ”´ é«˜ |
| **é¢„è¨€æœº** | ä½¿ç”¨TWAPè€Œéå³æ—¶ä»·æ ¼ | ğŸŸ¡ ä¸­ |

---

## ç³»åˆ—æ€»ç»“

æ­å–œä½ å®Œæˆäº†ã€Œæ­»ç£•Uniswap V2ã€ç³»åˆ—çš„å…¨éƒ¨å­¦ä¹ ï¼

### æ ¸å¿ƒçŸ¥è¯†å›é¡¾

1. **V2æ¦‚è¿°ä¸æ ¸å¿ƒåŸç†** - æ’å®šä¹˜ç§¯AMM (x Ã— y = k)
2. **Factoryä¸Pairåˆçº¦** - åˆçº¦ç»“æ„ä¸åˆ›å»ºæµç¨‹
3. **æµåŠ¨æ€§ä¸LPä»£å¸** - mint/burnä¸ä»½é¢è®¡ç®—
4. **äº¤æ¢æœºåˆ¶æ·±åº¦è§£æ** - swapå‡½æ•°ã€æ»‘ç‚¹ã€Flash Swap
5. **ä»·æ ¼é¢„è¨€æœº** - TWAPæœºåˆ¶ä¸é˜²æ“çºµ
6. **Routerä¸è·¯ç”±** - å¤šè·³äº¤æ˜“ä¸è·¯å¾„ä¼˜åŒ–
7. **å®‰å…¨å®è·µä¸æœ€ä½³å®è·µ** - æ¼æ´é˜²æŠ¤ä¸å¼€å‘å»ºè®®

### ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

- æ·±å…¥å­¦ä¹  Uniswap V3 çš„é›†ä¸­æµåŠ¨æ€§æœºåˆ¶
- äº†è§£ Uniswap V4 çš„ Hooks å¯ç¼–ç¨‹æ€§
- ç ”ç©¶å…¶ä»– AMM å˜ç§ (Curve, Balancer)
- å®è·µ DeFi åè®®é›†æˆå¼€å‘

---

## å‚è€ƒèµ„æ–™

- [Uniswap V2 Core Contracts](https://github.com/Uniswap/v2-core)
- [Uniswap V2 Periphery Contracts](https://github.com/Uniswap/v2-periphery)
- [Uniswap V2 Whitepaper](https://uniswap.org/whitepaper.pdf)
- [Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [OpenZeppelin Security Audit Checklist](https://docs.openzeppelin.com/contracts/security/)
