# æ­»ç£•Uniswap V4ï¼ˆä¸ƒï¼‰ï¼šå®‰å…¨åˆ†æä¸æœ€ä½³å®è·µ

> æœ¬æ–‡æ˜¯ã€Œæ­»ç£•Uniswap V4ã€ç³»åˆ—çš„æœ€åä¸€ç¯‡ï¼Œå…¨é¢åˆ†æV4çš„å®‰å…¨è€ƒè™‘å’Œå¼€å‘æœ€ä½³å®è·µã€‚

## ç³»åˆ—å¯¼èˆª

| åºå· | æ ‡é¢˜ | æ ¸å¿ƒå†…å®¹ |
|:----:|------|----------|
| 01 | V4æ¦‚è¿°ä¸æ¶æ„é©å‘½ | Singletonã€Hooksã€Flash Accounting |
| 02 | Hooksæœºåˆ¶æ·±åº¦è§£æ | Hookæ¥å£ã€ç”Ÿå‘½å‘¨æœŸã€å®ç°æ¨¡å¼ |
| 03 | å•ä¾‹æ¶æ„ä¸ç¬æ—¶ä¼šè®¡ | PoolManagerã€Currencyã€Accounting |
| 04 | äº¤æ¢æµç¨‹ä¸Hookæ‰§è¡Œæ—¶åº | swapå‡½æ•°ã€Hookè°ƒç”¨é“¾ã€Gasåˆ†æ |
| 05 | è´¹ç”¨ç³»ç»Ÿä¸åŠ¨æ€è´¹ç‡ | è‡ªå®šä¹‰è´¹ç‡ã€åŠ¨æ€è°ƒæ•´ã€è´¹ç”¨åˆ†é… |
| 06 | è´¦æˆ·æŠ½è±¡ä¸åŸç”ŸETH | Currencyç±»å‹ã€settle/takeã€æ‰¹é‡æ“ä½œ |
| **07** | **å®‰å…¨åˆ†æä¸æœ€ä½³å®è·µ** | **Hookå®‰å…¨ã€MEVé˜²æŠ¤ã€å®¡è®¡è¦ç‚¹** |

---

## 1. Hookå®‰å…¨æ¡†æ¶

### 1.1 Hookå®‰å…¨è€ƒè™‘

```mermaid
mindmap
  root((Hookå®‰å…¨))
    æƒé™æ§åˆ¶
      onlyPoolManager
      msg.senderéªŒè¯
      å‡½æ•°è®¿é—®æ§åˆ¶
    é‡å…¥ä¿æŠ¤
      nonReentrantä¿®é¥°ç¬¦
      lockedçŠ¶æ€æ£€æŸ¥
      Calls-Only-Hook
    çŠ¶æ€éªŒè¯
      å‚æ•°éªŒè¯
      è¾¹ç•Œæ£€æŸ¥
      æº¢å‡ºä¿æŠ¤
    å¤–éƒ¨è°ƒç”¨
      é™æ€è°ƒç”¨ä¼˜å…ˆ
      å¼‚å¸¸å¤„ç†
      Gasé™åˆ¶
    æ•°æ®å®Œæ•´æ€§
      è¾“å…¥éªŒè¯
      è¾“å‡ºéªŒè¯
      äº‹ä»¶è®°å½•
```

### 1.2 åŸºç¡€å®‰å…¨æ¨¡æ¿

```solidity
/// @notice å®‰å…¨HookåŸºç¡€åˆçº¦
abstract contract SecureHook is IHooks {
    IPoolManager public immutable poolManager;

    /// @notice é”å®šçŠ¶æ€ï¼ˆé˜²æ­¢é‡å…¥ï¼‰
    uint256 private locked = 1;

    /// @notice ä¿®é¥°ç¬¦ï¼šä»…PoolManagerå¯è°ƒç”¨
    modifier onlyPoolManager() {
        require(msg.sender == address(poolManager), "Not PoolManager");
        _;
    }

    /// @notice ä¿®é¥°ç¬¦ï¼šé˜²æ­¢é‡å…¥
    modifier nonReentrant() {
        require(locked == 1, "Reentrant");
        locked = 2;
        _;
        locked = 1;
    }

    /// @notice ä¿®é¥°ç¬¦ï¼šä»…åœ¨é”å®šçŠ¶æ€ä¸‹å¯è°ƒç”¨
    modifier onlyLocked() {
        require(poolManager.locked() != 0, "Not locked");
        _;
    }

    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }

    /// @notice å®‰å…¨çš„äº‹ä»¶è®°å½•
    event HookCalled(bytes4 indexed selector, address indexed caller);
    event HookFailed(bytes4 indexed selector, bytes reason);

    /// @notice å®‰å…¨çš„Hookè°ƒç”¨åŒ…è£…
    function _safeHookCall(
        bytes4 selector,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returnData) = address(this).delegatecall(data);

        if (!success) {
            emit HookFailed(selector, returnData);
            revert(string(abi.encodePacked(errorMessage, ": ", returnData)));
        }

        emit HookCalled(selector, msg.sender);
        return returnData;
    }
}
```

### 1.3 æƒé™æ§åˆ¶å®ç°

```solidity
/// @notice å¸¦æƒé™æ§åˆ¶çš„Hook
contract AccessControlledHook is SecureHook {
    /// @notice è§’è‰²å®šä¹‰
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");

    /// @notice è§’è‰²æ˜ å°„
    mapping(bytes32 => mapping(address => bool)) public roles;

    /// @notice ç®¡ç†å‘˜åœ°å€
    address public admin;

    /// @notice ä¿®é¥°ç¬¦ï¼šä»…ç®¡ç†å‘˜
    modifier onlyAdmin() {
        require(msg.sender == admin, "Not admin");
        _;
    }

    /// @notice ä¿®é¥°ç¬¦ï¼šæ‹¥æœ‰æŒ‡å®šè§’è‰²
    modifier onlyRole(bytes32 role) {
        require(roles[role][msg.sender], "Missing role");
        _;
    }

    constructor(IPoolManager _poolManager) SecureHook(_poolManager) {
        admin = msg.sender;
        roles[ADMIN_ROLE][msg.sender] = true;
    }

    /// @notice æˆäºˆè§’è‰²
    function grantRole(bytes32 role, address account) external onlyAdmin {
        roles[role][account] = true;
        emit RoleGranted(role, account, msg.sender);
    }

    /// @notice æ’¤é”€è§’è‰²
    function revokeRole(bytes32 role, address account) external onlyAdmin {
        roles[role][account] = false;
        emit RoleRevoked(role, account, msg.sender);
    }

    /// @notice è½¬è®©ç®¡ç†å‘˜
    function transferAdmin(address newAdmin) external onlyAdmin {
        require(newAdmin != address(0), "Zero address");
        admin = newAdmin;
        emit AdminTransferred(admin, newAdmin);
    }

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event AdminTransferred(address indexed oldAdmin, address indexed newAdmin);
}
```

---

## 2. å¸¸è§æ¼æ´ä¸é˜²æŠ¤

### 2.1 é‡å…¥æ”»å‡»é˜²æŠ¤

```solidity
/// @notice é‡å…¥æ”»å‡»é˜²æŠ¤
contract ReentrancyGuard is IHooks {
    IPoolManager public immutable poolManager;

    /// @notice é‡å…¥é”çŠ¶æ€
    uint256 private locked = 1;

    /// @notice ä¿®é¥°ç¬¦ï¼šé˜²æ­¢é‡å…¥
    modifier nonReentrant() {
        require(locked == 1, "Reentrant call");
        locked = 2;
        _;
        locked = 1;
    }

    /// @notice å®‰å…¨çš„èµ„é‡‘è½¬ç§»
    function _safeTransfer(
        address token,
        address to,
        uint256 amount
    ) private nonReentrant {
        if (token == address(0)) {
            // åŸç”ŸETH
            payable(to).transfer(amount);
        } else {
            // ERC20
            (bool success, bytes memory data) = token.call(
                abi.encodeWithSignature(
                    "transfer(address,uint256)",
                    to,
                    amount
                )
            );

            require(
                success && (data.length == 0 || abi.decode(data, (bool))),
                "Transfer failed"
            );
        }
    }

    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        bytes calldata hookData
    ) external nonReentrant returns (bytes4, int256, int256) {
        // Hooké€»è¾‘
        return (IHooks.beforeSwap.selector, 0, 0);
    }
}
```

### 2.2 æ•´æ•°æº¢å‡ºé˜²æŠ¤

```solidity
/// @notice æ•´æ•°æº¢å‡ºé˜²æŠ¤
pragma solidity ^0.8.0; // Solidity 0.8.xè‡ªåŠ¨æ£€æŸ¥æº¢å‡º

/// @notice å¸¦æº¢å‡ºæ£€æŸ¥çš„æ•°å­¦åº“
library SafeMathLib {
    /// @notice å®‰å…¨åŠ æ³•
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Overflow");
        return c;
    }

    /// @notice å®‰å…¨å‡æ³•
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(a >= b, "Underflow");
        return a - b;
    }

    /// @notice å®‰å…¨ä¹˜æ³•
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) return 0;
        uint256 c = a * b;
        require(c / a == b, "Overflow");
        return c;
    }

    /// @notice å®‰å…¨é™¤æ³•
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "Division by zero");
        return a / b;
    }
}

/// @notice ä½¿ç”¨SafeMathçš„Hook
contract OverflowProtectedHook is IHooks {
    using SafeMathLib for uint256;

    IPoolManager public immutable poolManager;

    /// @notice ç´¯ç§¯å€¼ï¼ˆé˜²æ­¢æº¢å‡ºï¼‰
    uint256 public cumulativeValue;

    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        bytes calldata hookData
    ) external returns (bytes4, int256, int256) {
        // å®‰å…¨çš„ç´¯åŠ 
        uint256 amount = uint256(abs(params.amountSpecified));
        cumulativeValue = cumulativeValue.add(amount);

        // æ£€æŸ¥ä¸Šé™
        require(cumulativeValue <= type(uint256).max / 2, "Cumulative value too high");

        return (IHooks.beforeSwap.selector, 0, 0);
    }

    function abs(int256 x) private pure returns (uint256) {
        return x >= 0 ? uint256(x) : uint256(-x);
    }
}
```

### 2.3 å‰ç«¯è¿è¡Œé˜²æŠ¤

```solidity
/// @notice å‰ç«¯è¿è¡Œé˜²æŠ¤
contract FrontendRunProtection is IHooks {
    IPoolManager public immutable poolManager;

    /// @notice æœ€å°å»¶è¿Ÿ
    uint256 public constant MIN_DELAY = 1 seconds;

    /// @notice å¾…å¤„ç†äº¤æ˜“
    mapping(bytes32 => PendingTx) public pendingTxs;

    struct PendingTx {
        address sender;
        uint256 amount;
        uint256 timestamp;
        bool executed;
    }

    /// @notice æäº¤äº¤æ˜“æ„å‘
    function commitSwap(
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params
    ) external returns (bytes32) {
        bytes32 txHash = keccak256(abi.encode(
            msg.sender,
            key,
            params,
            block.number
        ));

        pendingTxs[txHash] = PendingTx({
            sender: msg.sender,
            amount: uint256(abs(params.amountSpecified)),
            timestamp: block.timestamp,
            executed: false
        });

        emit SwapCommitted(msg.sender, txHash, params);
        return txHash;
    }

    /// @notice æ‰§è¡Œå·²æäº¤çš„äº¤æ˜“
    function executeSwap(
        bytes32 txId,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params
    ) external returns (BalanceDelta) {
        PendingTx storage pending = pendingTxs[txId];

        // éªŒè¯
        require(pending.sender == msg.sender, "Not committer");
        require(!pending.executed, "Already executed");
        require(
            block.timestamp >= pending.timestamp + MIN_DELAY,
            "Too early"
        );

        // æ ‡è®°ä¸ºå·²æ‰§è¡Œ
        pending.executed = true;

        // æ‰§è¡Œäº¤æ¢
        BalanceDelta memory delta = poolManager.swap(key, params, BalanceDelta(0, 0));

        emit SwapExecuted(msg.sender, txId, delta);
        return delta;
    }

    function abs(int256 x) private pure returns (uint256) {
        return x >= 0 ? uint256(x) : uint256(-x);
    }

    event SwapCommitted(address indexed sender, bytes32 txId, IPoolManager.SwapParams params);
    event SwapExecuted(address indexed sender, bytes32 txId, BalanceDelta delta);
}
```

### 2.4 ä¸‰æ˜æ²»æ”»å‡»é˜²æŠ¤

```solidity
/// @notice ä¸‰æ˜æ²»æ”»å‡»é˜²æŠ¤
contract SandwichProtection is IHooks {
    IPoolManager public immutable poolManager;

    /// @notice ä»·æ ¼å½±å“é˜ˆå€¼
    uint256 public priceImpactThreshold = 100; // 1%

    /// @notice äº¤æ˜“æ—¶é—´çª—å£
    uint256 public timeWindow = 3 seconds;

    /// @notice ç”¨æˆ·äº¤æ˜“æ˜ å°„
    mapping(address => UserTx) public userTxs;

    struct UserTx {
        uint256 timestamp;
        uint256 amount;
        bool inMempool;
    }

    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        bytes calldata hookData
    ) external returns (bytes4, int256, int256) {
        bytes32 poolId = key.poolId;
        uint256 amount = uint256(abs(params.amountSpecified));

        // æ£€æŸ¥ä¸‰æ˜æ²»æ”»å‡»æ¨¡å¼
        if (_detectSandwich(sender, poolId, amount)) {
            revert("Suspected sandwich attack");
        }

        // è®°å½•ç”¨æˆ·äº¤æ˜“
        userTxs[sender] = UserTx({
            timestamp: block.timestamp,
            amount: amount,
            inMempool: true
        });

        // æ£€æŸ¥ä»·æ ¼å½±å“
        uint256 priceImpact = _calculatePriceImpact(key, params);
        if (priceImpact > priceImpactThreshold) {
            revert("Price impact too high");
        }

        return (IHooks.beforeSwap.selector, 0, 0);
    }

    function _detectSandwich(
        address sender,
        bytes32 poolId,
        uint256 amount
    ) private view returns (bool) {
        // æ£€æŸ¥æ—¶é—´çª—å£å†…çš„å¤§é¢äº¤æ˜“
        if (block.timestamp < userTxs[sender].timestamp + timeWindow) {
            // å¦‚æœåœ¨æ—¶é—´çª—å£å†…å†æ¬¡äº¤æ˜“ï¼Œä¸”é‡‘é¢æ›´å¤§ï¼Œå¯èƒ½æ˜¯ä¸‰æ˜æ²»
            if (amount > userTxs[sender].amount * 2) {
                return true;
            }
        }
        return false;
    }

    function _calculatePriceImpact(
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params
    ) private view returns (uint256) {
        (uint160 sqrtPriceX96, , , ) = poolManager.slot0s(key.poolId);

        // ç®€åŒ–çš„ä»·æ ¼å½±å“è®¡ç®—
        uint256 priceImpact = uint256(abs(params.amountSpecified)) * 1e18 / uint256(sqrtPriceX96);

        return priceImpact / 1e14; // è½¬æ¢ä¸ºç™¾åˆ†æ¯”
    }

    function abs(int256 x) private pure returns (uint256) {
        return x >= 0 ? uint256(x) : uint256(-x);
    }

    // æš´éœ²çš„setterç”¨äºæµ‹è¯•
    function setPriceImpactThreshold(uint256 threshold) external {
        priceImpactThreshold = threshold;
    }
}
```

---

## 3. MEVé˜²æŠ¤ç­–ç•¥

### 3.1 MEVç±»å‹åˆ†æ

```mermaid
graph TB
    subgraph MEVTypes["MEVæ”»å‡»ç±»å‹"]
        M1[æŠ¢è·‘äº¤æ˜“<br/>Front-running]
        M2[ä¸‰æ˜æ²»æ”»å‡»<br/>Sandwich]
        M3[æ¸…ç®—æŠ¢è·‘<br/>Liquidation]
        M4[å¥—åˆ©ç«äº‰<br/>Arbitrage]
    end

    subgraph Defenses["é˜²æŠ¤ç­–ç•¥"]
        D1[æ—¶é—´é”<br/>Time-lock]
        D2[æ‰¹é‡æ‰§è¡Œ<br/>Batch execution]
        D3[åŠ å¯†æš—æ± <br/>Encrypted pool]
        D4[ä¼˜å…ˆè´¹æ‹å–<br/>Priority fee]
    end

    M1 --> D1
    M2 --> D2
    M3 --> D1
    M4 --> D4

    style Defenses fill:#c8e6c9
```

### 3.2 æ—¶é—´é”å®ç°

```solidity
/// @notice å¸¦æ—¶é—´é”çš„Hook
contract TimelockHook is IHooks {
    IPoolManager public immutable poolManager;

    /// @notice æ—¶é—´é”é…ç½®
    struct TimelockConfig {
        uint256 delay;      // å»¶è¿Ÿæ—¶é—´
        uint256 gracePeriod; // å®½é™æœŸ
    }

    mapping(bytes32 => TimelockConfig) public timelockConfigs;

    /// @notice å¾…å¤„ç†æ“ä½œ
    struct PendingOperation {
        address sender;
        bytes32 dataHash;
        uint256 readyTime;
        uint256 deadline;
        bool executed;
        bool cancelled;
    }

    mapping(bytes32 => PendingOperation) public pendingOps;

    /// @notice æäº¤æ“ä½œ
    function submitOperation(
        bytes32 poolId,
        bytes calldata data
    ) external returns (bytes32) {
        TimelockConfig memory config = timelockConfigs[poolId];
        require(config.delay > 0, "No timelock configured");

        bytes32 opId = keccak256(abi.encode(
            msg.sender,
            poolId,
            data,
            block.number
        ));

        uint256 readyTime = block.timestamp + config.delay;
        uint256 deadline = readyTime + config.gracePeriod;

        pendingOps[opId] = PendingOperation({
            sender: msg.sender,
            dataHash: keccak256(data),
            readyTime: readyTime,
            deadline: deadline,
            executed: false,
            cancelled: false
        });

        emit OperationSubmitted(msg.sender, opId, readyTime, deadline);
        return opId;
    }

    /// @notice æ‰§è¡Œæ“ä½œ
    function executeOperation(
        bytes32 opId,
        bytes32 poolId,
        bytes calldata data
    ) external {
        PendingOp storage op = pendingOps[opId];

        require(op.sender == msg.sender, "Not submitter");
        require(!op.executed && !op.cancelled, "Invalid state");
        require(block.timestamp >= op.readyTime, "Too early");
        require(block.timestamp <= op.deadline, "Expired");
        require(keccak256(data) == op.dataHash, "Data mismatch");

        op.executed = true;

        // æ‰§è¡Œæ“ä½œ
        _executeData(poolId, data);

        emit OperationExecuted(msg.sender, opId);
    }

    /// @notice å–æ¶ˆæ“ä½œ
    function cancelOperation(bytes32 opId) external {
        PendingOp storage op = pendingOps[opId];

        require(op.sender == msg.sender, "Not submitter");
        require(!op.executed && !op.cancelled, "Invalid state");
        require(block.timestamp < op.readyTime, "Already ready");

        op.cancelled = true;

        emit OperationCancelled(msg.sender, opId);
    }

    function _executeData(bytes32 poolId, bytes calldata data) private {
        // å®ç°æ•°æ®æ‰§è¡Œé€»è¾‘
    }

    event OperationSubmitted(address indexed sender, bytes32 opId, uint256 readyTime, uint256 deadline);
    event OperationExecuted(address indexed sender, bytes32 opId);
    event OperationCancelled(address indexed sender, bytes32 opId);
}
```

### 3.3 æ‰¹é‡æ‰§è¡Œä¿æŠ¤

```solidity
/// @notice æ‰¹é‡æ‰§è¡Œä¿æŠ¤Hook
contract BatchExecutionProtection is IHooks {
    IPoolManager public immutable poolManager;

    /// @notice æ‰¹é‡é…ç½®
    struct BatchConfig {
        uint256 maxSize;       // æœ€å¤§æ‰¹é‡å¤§å°
        uint256 maxDelay;       // æœ€å¤§å»¶è¿Ÿ
        uint256 minSize;        // æœ€å°æ‰¹é‡å¤§å°
        bool enabled;           // æ˜¯å¦å¯ç”¨
    }

    mapping(bytes32 => BatchConfig) public batchConfigs;

    /// @notice æ‰¹é‡äº¤æ˜“
    struct Batch {
        address[] participants;
        IPoolManager.SwapParams[] params;
        uint256 startTime;
        uint256 currentSize;
    }

    mapping(bytes32 => Batch) public batches;

    /// @notice åˆ›å»ºæ‰¹é‡
    function createBatch(
        bytes32 poolId,
        uint256 maxSize
    ) external returns (bytes32) {
        batchConfigs[poolId].enabled = true;
        batchConfigs[poolId].maxSize = maxSize;

        bytes32 batchId = keccak256(abi.encode(poolId, block.timestamp));

        batches[batchId] = Batch({
            participants: new address[](maxSize),
            params: new IPoolManager.SwapParams[](maxSize),
            startTime: block.timestamp,
            currentSize: 0
        });

        emit BatchCreated(poolId, batchId, maxSize);
        return batchId;
    }

    /// @notice åŠ å…¥æ‰¹é‡
    function joinBatch(
        bytes32 batchId,
        IPoolManager.SwapParams calldata params
    ) external {
        Batch storage batch = batches[batchId];

        require(batch.currentSize < batch.participants.length, "Batch full");
        require(
            block.timestamp < batch.startTime + batchConfigs[batchId].maxDelay,
            "Batch expired"
        );

        batch.participants[batch.currentSize] = msg.sender;
        batch.params[batch.currentSize] = params;
        batch.currentSize++;

        emit JoinedBatch(msg.sender, batchId, batch.currentSize);
    }

    /// @notice æ‰§è¡Œæ‰¹é‡
    function executeBatch(bytes32 batchId, PoolKey calldata key) external {
        Batch storage batch = batches[batchId];

        require(batch.currentSize >= batchConfigs[batchId].minSize, "Batch too small");
        require(
            block.timestamp >= batch.startTime + 1 minutes,
            "Too early to execute"
        );

        // éšæœºåŒ–æ‰§è¡Œé¡ºåº
        uint256[] memory order = _shuffleArray(batch.currentSize);

        for (uint256 i = 0; i < order.length; i++) {
            uint256 idx = order[i];
            address participant = batch.participants[idx];

            // æ‰§è¡Œäº¤æ¢
            poolManager.swap(key, batch.params[idx], BalanceDelta(0, 0));

            emit BatchSwapExecuted(participant, batchId, idx);
        }

        delete batches[batchId];
        emit BatchExecuted(batchId);
    }

    function _shuffleArray(uint256 size) private view returns (uint256[] memory) {
        uint256[] memory order = new uint256[](size);
        for (uint256 i = 0; i < size; i++) {
            order[i] = i;
        }

        // Fisher-Yates shuffle
        for (uint256 i = size - 1; i > 0; i--) {
            uint256 j = uint256(keccak256(abi.encode(
                block.prevrandao,
                batchId,
                i
            ))) % (i + 1);

            (order[i], order[j]) = (order[j], order[i]);
        }

        return order;
    }

    event BatchCreated(bytes32 indexed poolId, bytes32 batchId, uint256 maxSize);
    event JoinedBatch(address indexed participant, bytes32 batchId, uint256 position);
    event BatchExecuted(bytes32 batchId);
    event BatchSwapExecuted(address indexed participant, bytes32 batchId, uint256 index);
}
```

---

## 4. å¼€å‘æœ€ä½³å®è·µ

### 4.1 Hookå¼€å‘æ£€æŸ¥æ¸…å•

```solidity
/// @notice Hookå¼€å‘æ£€æŸ¥æ¸…å•
contract HookChecklist {
    // ========== å®‰å…¨æ£€æŸ¥ ==========

    // âœ… 1. æƒé™æ§åˆ¶
    // - [ ] æ·»åŠ  onlyPoolManager ä¿®é¥°ç¬¦
    // - [ ] éªŒè¯ msg.sender
    // - [ ] å®ç°è§’è‰²è®¿é—®æ§åˆ¶

    // âœ… 2. é‡å…¥ä¿æŠ¤
    // - [ ] æ·»åŠ  nonReentrant ä¿®é¥°ç¬¦
    // - [ ] ä½¿ç”¨ Checks-Effects-Interactions æ¨¡å¼
    // - [ ] é¿å…åœ¨ Hook ä¸­è°ƒç”¨å¤–éƒ¨åˆçº¦

    // âœ… 3. çŠ¶æ€éªŒè¯
    // - [ ] éªŒè¯æ‰€æœ‰è¾“å…¥å‚æ•°
    // - [ ] æ£€æŸ¥è¾¹ç•Œæ¡ä»¶
    // - [ ] é˜²æ­¢æ•´æ•°æº¢å‡º

    // ========== Gasä¼˜åŒ– ==========

    // âœ… 4. å­˜å‚¨ä¼˜åŒ–
    // - [ ] ä½¿ç”¨ immutable å˜é‡
    // - [ ] æ‰“åŒ…å­˜å‚¨å˜é‡
    // - [ ] ç¼“å­˜å­˜å‚¨è¯»å–

    // âœ… 5. è®¡ç®—ä¼˜åŒ–
    // - [ ] é¢„è®¡ç®—å¸¸é‡å€¼
    // - [ ] ä½¿ç”¨çŸ­è·¯æ±‚å€¼
    // - [ ] æ‰¹é‡æ“ä½œ

    // ========== å¯ç»´æŠ¤æ€§ ==========

    // âœ… 6. äº‹ä»¶è®°å½•
    // - [ ] è®°å½•æ‰€æœ‰é‡è¦æ“ä½œ
    // - [ ] ä½¿ç”¨ indexed å‚æ•°
    // - [ ] æ·»åŠ è¯¦ç»†è¯´æ˜

    // âœ… 7. é”™è¯¯å¤„ç†
    // - [ ] å®šä¹‰æ¸…æ™°çš„é”™è¯¯ç 
    // - [ ] æä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯
    // - [ ] å¤„ç†å¼‚å¸¸æƒ…å†µ

    // âœ… 8. æµ‹è¯•è¦†ç›–
    // - [ ] å•å…ƒæµ‹è¯•
    // - [ ] é›†æˆæµ‹è¯•
    // - [ ] è¾¹ç•Œæ¡ä»¶æµ‹è¯•
}
```

### 4.2 Hookæ¨¡æ¿

```solidity
/// @notice æ ‡å‡†Hookæ¨¡æ¿
/// @dev åŒ…å«æ‰€æœ‰å®‰å…¨æœ€ä½³å®è·µçš„HookåŸºç±»
abstract contract StandardHook is IHooks {
    /// @notice immutable å˜é‡
    IPoolManager public immutable poolManager;

    /// @notice é”™è¯¯ç 
    error NotPoolManager();
    error InvalidParameters();
    error HookFailed();

    /// @notice äº‹ä»¶
    event HookExecuted(bytes4 indexed selector, address indexed caller);

    /// @notice ä¿®é¥°ç¬¦
    modifier onlyPoolManager() {
        if (msg.sender != address(poolManager)) revert NotPoolManager();
        _;
    }

    /// @notice æ„é€ å‡½æ•°
    constructor(IPoolManager _poolManager) {
        poolManager = _poolManager;
    }

    /// @notice é»˜è®¤Hookå®ç°ï¼ˆå¯è¦†ç›–ï¼‰
    function beforeInitialize(
        address sender,
        PoolKey calldata key,
        uint160 sqrtPriceX96,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4) {
        emit HookExecuted(IHooks.beforeInitialize.selector, sender);
        return IHooks.beforeInitialize.selector;
    }

    function afterInitialize(
        address sender,
        PoolKey calldata key,
        uint160 sqrtPriceX96,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4) {
        emit HookExecuted(IHooks.afterInitialize.selector, sender);
        return IHooks.afterInitialize.selector;
    }

    function beforeModifyPosition(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyPositionParams calldata params,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4, int256 delta0, int256 delta1) {
        emit HookExecuted(IHooks.beforeModifyPosition.selector, sender);
        return (IHooks.beforeModifyPosition.selector, 0, 0);
    }

    function afterModifyPosition(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyPositionParams calldata params,
        BalanceDelta callerDelta,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4) {
        emit HookExecuted(IHooks.afterModifyPosition.selector, sender);
        return IHooks.afterModifyPosition.selector;
    }

    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4, int256 delta0, int256 delta1) {
        emit HookExecuted(IHooks.beforeSwap.selector, sender);
        return (IHooks.beforeSwap.selector, 0, 0);
    }

    function afterSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        BalanceDelta callerDelta,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4) {
        emit HookExecuted(IHooks.afterSwap.selector, sender);
        return IHooks.afterSwap.selector;
    }

    function beforeDonate(
        address sender,
        PoolKey calldata key,
        uint256 amount0,
        uint256 amount1,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4) {
        emit HookExecuted(IHooks.beforeDonate.selector, sender);
        return IHooks.beforeDonate.selector;
    }

    function afterDonate(
        address sender,
        PoolKey calldata key,
        uint256 amount0,
        uint256 amount1,
        bytes calldata hookData
    ) external onlyPoolManager virtual returns (bytes4) {
        emit HookExecuted(IHooks.afterDonate.selector, sender);
        return IHooks.afterDonate.selector;
    }
}
```

### 4.3 æµ‹è¯•æ¨¡æ¿

```solidity
/// @notice Hookæµ‹è¯•æ¨¡æ¿
contract HookTest is Test {
    Hook target;
    PoolManager poolManager;
    PoolKey poolKey;

    address user = address(0x1);
    address admin = address(0x2);

    function setUp() public {
        // éƒ¨ç½²ä¾èµ–åˆçº¦
        poolManager = new PoolManager();

        // éƒ¨ç½²Hook
        target = new Hook(poolManager);

        // è®¾ç½®æµ‹è¯•æ± å­
        poolKey = PoolKey({
            currency0: CurrencyLibrary.NATIVE,
            currency1: Currency.wrap(address(usdc)),
            fee: 3000,
            tickSpacing: 60,
            hooks: target
        });

        // åˆå§‹åŒ–æ± å­
        poolManager.initialize(poolKey, uint160(79228162514264337593543950336));
    }

    function testBeforeSwap_ReturnsCorrectSelector() public {
        (bytes4 selector,,) = target.beforeSwap(
            user,
            poolKey,
            SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: TickMath.MIN_SQRT_RATIO + 1,
                hookData: ""
            }),
            ""
        );

        assertEq(selector, IHooks.beforeSwap.selector);
    }

    function testBeforeSwap_RevertsWithInvalidParams() public {
        vm.expectRevert();
        target.beforeSwap(
            address(0), // æ— æ•ˆåœ°å€
            poolKey,
            SwapParams({
                zeroForOne: true,
                amountSpecified: -1, // æ— æ•ˆæ•°é‡
                sqrtPriceLimitX96: 0,
                hookData: ""
            }),
            ""
        );
    }

    function testFuzz_BeforeSwap(int256 amount) public {
        vm.assume(amount > 0);
        vm.assume(amount < 1e30);

        (bytes4 selector,,) = target.beforeSwap(
            user,
            poolKey,
            SwapParams({
                zeroForOne: true,
                amountSpecified: amount,
                sqrtPriceLimitX96: TickMath.MIN_SQRT_RATIO + 1,
                hookData: ""
            }),
            ""
        );

        assertEq(selector, IHooks.beforeSwap.selector);
    }

    function testAccessControl() public {
        // éªŒè¯åªæœ‰PoolManagerå¯ä»¥è°ƒç”¨
        vm.prank(user);
        vm.expectRevert(StandardHook.NotPoolManager.selector);
        target.beforeSwap(
            user,
            poolKey,
            SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: TickMath.MIN_SQRT_RATIO + 1,
                hookData: ""
            }),
            ""
        );
    }
}
```

---

## 5. å®¡è®¡è¦ç‚¹

### 5.1 å®¡è®¡æ£€æŸ¥æ¸…å•

```mermaid
mindmap
  root((å®¡è®¡æ¸…å•))
    æƒé™æ§åˆ¶
      onlyPoolManager
      è§’è‰²éªŒè¯
      ç®¡ç†å‘˜æƒé™
    çŠ¶æ€ç®¡ç†
      é‡å…¥ä¿æŠ¤
      æº¢å‡ºæ£€æŸ¥
      è¾¹ç•Œæ¡ä»¶
    å¤–éƒ¨äº¤äº’
      è°ƒç”¨éªŒè¯
      å¼‚å¸¸å¤„ç†
      Gasé™åˆ¶
    æ•°æ®å®Œæ•´æ€§
      å‚æ•°éªŒè¯
      çŠ¶æ€ä¸€è‡´æ€§
      äº‹ä»¶æ—¥å¿—
    ä¸šåŠ¡é€»è¾‘
      è´¹ç”¨è®¡ç®—
      ä»·æ ¼éªŒè¯
      å·®é¢ç»“ç®—
```

### 5.2 å…³é”®å®¡è®¡ç‚¹

| å®¡è®¡ç‚¹ | æ£€æŸ¥å†…å®¹ | é£é™©ç­‰çº§ |
|--------|----------|----------|
| **æƒé™æ§åˆ¶** | Hookè°ƒç”¨è€…éªŒè¯ | ğŸ”´ é«˜ |
| **é‡å…¥ä¿æŠ¤** | nonReentrantæ­£ç¡®ä½¿ç”¨ | ğŸ”´ é«˜ |
| **çŠ¶æ€ä¸€è‡´æ€§** | Hookå¤±è´¥åçš„çŠ¶æ€ | ğŸ”´ é«˜ |
| **æ•´æ•°æº¢å‡º** | æ•°å­¦è¿ç®—è¾¹ç•Œ | ğŸŸ¡ ä¸­ |
| **å¤–éƒ¨è°ƒç”¨** | æ¶æ„åˆçº¦é£é™© | ğŸŸ¡ ä¸­ |
| **Gasé™åˆ¶** | DoSæ”»å‡»é˜²æŠ¤ | ğŸŸ¡ ä¸­ |
| **äº‹ä»¶æ—¥å¿—** | æ“ä½œå¯è¿½æº¯æ€§ | ğŸŸ¢ ä½ |
| **æµ‹è¯•è¦†ç›–** | ä»£ç æµ‹è¯•å®Œæ•´æ€§ | ğŸŸ¢ ä½ |

### 5.3 å¸¸è§æ¼æ´æ¨¡å¼

```solidity
/// @notice å¸¸è§æ¼æ´ç¤ºä¾‹å’Œä¿®å¤

// ========================================
// æ¼æ´1: ç¼ºå°‘æƒé™æ§åˆ¶
// ========================================

// âŒ é”™è¯¯ï¼šä»»ä½•äººéƒ½å¯ä»¥è°ƒç”¨
function beforeSwap(...) external returns (bytes4, int256, int256) {
    // ä»»ä½•äººéƒ½å¯ä»¥è°ƒç”¨è¿™ä¸ªHook
    return (IHooks.beforeSwap.selector, 0, 0);
}

// âœ… æ­£ç¡®ï¼šæ·»åŠ æƒé™æ§åˆ¶
function beforeSwap(...) external onlyPoolManager returns (bytes4, int256, int256) {
    // åªæœ‰PoolManagerå¯ä»¥è°ƒç”¨
    return (IHooks.beforeSwap.selector, 0, 0);
}

// ========================================
// æ¼æ´2: é‡å…¥æ¼æ´
// ========================================

// âŒ é”™è¯¯ï¼šæ²¡æœ‰é‡å…¥ä¿æŠ¤
function beforeSwap(...) external returns (bytes4, int256, int256) {
    // è°ƒç”¨å¤–éƒ¨åˆçº¦
    externalContract.call();
    return (IHooks.beforeSwap.selector, 0, 0);
}

// âœ… æ­£ç¡®ï¼šæ·»åŠ é‡å…¥ä¿æŠ¤
function beforeSwap(...) external nonReentrant returns (bytes4, int256, int256) {
    // å…ˆæ›´æ–°çŠ¶æ€
    _updateState();

    // æœ€åè°ƒç”¨å¤–éƒ¨åˆçº¦
    externalContract.call();

    return (IHooks.beforeSwap.selector, 0, 0);
}

// ========================================
// æ¼æ´3: æœªéªŒè¯è¿”å›å€¼
// ========================================

// âŒ é”™è¯¯ï¼šæœªéªŒè¯Hookè¿”å›å€¼
function callHook(...) external {
    IHooks(hookAddress).beforeSwap(...); // æœªæ£€æŸ¥è¿”å›å€¼
}

// âœ… æ­£ç¡®ï¼šéªŒè¯è¿”å›å€¼
function callHook(...) external {
    (bool success, bytes memory data) = hookAddress.staticcall(...);
    if (!success) {
        // å¤„ç†å¤±è´¥
        revert("Hook call failed");
    }

    bytes4 selector = abi.decode(data, (bytes4));
    require(selector == IHooks.beforeSwap.selector, "Invalid selector");
}

// ========================================
// æ¼æ´4: æ•´æ•°æº¢å‡º
// ========================================

// âŒ é”™è¯¯ï¼šå¯èƒ½çš„æº¢å‡º
function calculateFee(uint256 amount, uint256 feeRate) public pure returns (uint256) {
    return amount * feeRate / 1e6; // å¯èƒ½æº¢å‡º
}

// âœ… æ­£ç¡®ï¼šå®‰å…¨çš„æ•°å­¦è¿ç®—
function calculateFee(uint256 amount, uint256 feeRate) public pure returns (uint256) {
    require(amount <= type(uint256).max / feeRate, "Overflow");
    return amount * feeRate / 1e6;
}
```

---

## 6. å®‰å…¨å·¥å…·å’Œèµ„æº

### 6.1 é™æ€åˆ†æå·¥å…·

| å·¥å…· | åŠŸèƒ½ | é“¾æ¥ |
|------|------|------|
| **Slither** | é™æ€åˆ†æï¼Œæ¼æ´æ£€æµ‹ | https://github.com/crytic/slither |
| **Mythril** | ç¬¦å·æ‰§è¡Œ | https://github.com/ConsenSys/mythril |
| **Echidna** | æ¨¡ç³Šæµ‹è¯• | https://github.com/crytic/echidna |
| **Foundry** | æµ‹è¯•æ¡†æ¶ | https://github.com/foundry-rs/foundry |

### 6.2 ä½¿ç”¨Slitherå®¡è®¡Hook

```bash
# å®‰è£…Slither
pip install slither-analyzer

# è¿è¡ŒSlither
slither . --detect reentrancy-eth,reentrancy-unlimited-gas

# ç”ŸæˆæŠ¥å‘Š
slither . --json output.json

# å¸¸ç”¨æ£€æµ‹å™¨
slither . --detect all
```

### 6.3 ä½¿ç”¨Foundryæµ‹è¯•

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/MyHook.sol";

contract MyHookTest is Test {
    MyHook target;
    PoolManager poolManager;

    function setUp() public {
        poolManager = new PoolManager();
        target = new MyHook(poolManager);
    }

    function test_Reentrancy() public {
        // æµ‹è¯•é‡å…¥æ”»å‡»
        vm.expectRevert();
        // ...æµ‹è¯•é€»è¾‘
    }

    function test_IntegerOverflow() public {
        // æµ‹è¯•æ•´æ•°æº¢å‡º
        // ...æµ‹è¯•é€»è¾‘
    }

    function test_FrontRunning() public {
        // æµ‹è¯•å‰ç«¯è¿è¡Œæ”»å‡»
        // ...æµ‹è¯•é€»è¾‘
    }

    function invariant_StateConsistency() public {
        // çŠ¶æ€ä¸€è‡´æ€§æ£€æŸ¥
        // ...æµ‹è¯•é€»è¾‘
    }
}
```

---

## 7. å®‰å…¨å»ºè®®æ€»ç»“

### 7.1 å¼€å‘æµç¨‹å»ºè®®

```mermaid
graph LR
    A[éœ€æ±‚åˆ†æ] --> B[æ¶æ„è®¾è®¡]
    B --> C[å®‰å…¨è®¾è®¡]
    C --> D[å®ç°ç¼–ç ]
    D --> E[å•å…ƒæµ‹è¯•]
    E --> F[é›†æˆæµ‹è¯•]
    F --> G[å®‰å…¨å®¡è®¡]
    G --> H[æ¼æ´ä¿®å¤]
    H --> I[éƒ¨ç½²ä¸Šçº¿]
    I --> J[ç›‘æ§åº”æ€¥]

    style C fill:#c8e6c9
    style G fill:#ffcdd2
```

### 7.2 å®‰å…¨å»ºè®®æ¸…å•

**å¼€å‘é˜¶æ®µï¼š**
- âœ… ä½¿ç”¨å®‰å…¨çš„Hookæ¨¡æ¿
- âœ… æ·»åŠ å®Œæ•´çš„è®¿é—®æ§åˆ¶
- âœ… å®ç°é‡å…¥ä¿æŠ¤
- âœ… è®°å½•è¯¦ç»†çš„äº‹ä»¶æ—¥å¿—
- âœ… ç¼–å†™å…¨é¢çš„æµ‹è¯•

**å®¡è®¡é˜¶æ®µï¼š**
- âœ… ä½¿ç”¨é™æ€åˆ†æå·¥å…·
- âœ… è¿›è¡Œæ¨¡ç³Šæµ‹è¯•
- âœ… é‚€è¯·ä¸“ä¸šå®¡è®¡
- âœ… è¿›è¡Œå½¢å¼åŒ–éªŒè¯
- âœ… æµ‹è¯•è¾¹ç•Œæ¡ä»¶

**éƒ¨ç½²é˜¶æ®µï¼š**
- âœ… å¤šç­¾æ§åˆ¶å‡çº§æƒé™
- âœ… è®¾ç½®æ—¶é—´é”
- âœ… å‡†å¤‡åº”æ€¥æ–¹æ¡ˆ
- âœ… é…ç½®ç›‘æ§å‘Šè­¦
- âœ… å‡†å¤‡æ¼æ´å“åº”è®¡åˆ’

---

## 8. ç³»åˆ—æ€»ç»“

### 8.1 V4æ ¸å¿ƒåˆ›æ–°å›é¡¾

| åˆ›æ–° | æè¿° | ä¼˜åŠ¿ |
|------|------|------|
| **Hooks** | ç”Ÿå‘½å‘¨æœŸå¯ç¼–ç¨‹ | æ— é™æ‰©å±•æ€§ |
| **Singleton** | å•ä¾‹æ¶æ„ | éƒ¨ç½²æˆæœ¬â†“95% |
| **Flash Accounting** | ç¬æ—¶ä¼šè®¡ | Gasä¼˜åŒ–30-40% |
| **Native ETH** | åŸç”Ÿæ”¯æŒ | GasèŠ‚çœ47% |
| **åŠ¨æ€è´¹ç”¨** | è‡ªå®šä¹‰è´¹ç‡ | ç²¾ç»†åŒ–å®šä»· |

### 8.2 å­¦ä¹ è·¯å¾„

```mermaid
flowchart LR
    A[åŸºç¡€ç†è§£<br/>01-æ¦‚è¿°] --> B[æ ¸å¿ƒæœºåˆ¶<br/>02-Hooks<br/>03-å•ä¾‹æ¶æ„]
    B --> C[æ·±å…¥ç»†èŠ‚<br/>04-äº¤æ¢æµç¨‹<br/>05-è´¹ç”¨ç³»ç»Ÿ]
    C --> D[é«˜çº§ç‰¹æ€§<br/>06-è´¦æˆ·æŠ½è±¡]
    D --> E[å®‰å…¨å®è·µ<br/>07-å®‰å…¨åˆ†æ]
    E --> F[å®è·µå¼€å‘<br/>æ„å»ºå®é™…é¡¹ç›®]

    style F fill:#c8e6c9
```

### 8.3 ç»§ç»­å­¦ä¹ èµ„æº

**å®˜æ–¹èµ„æºï¼š**
- [Uniswap V4 ç™½çš®ä¹¦](https://uniswap.org/whitepaper-v4.pdf)
- [Uniswap V4 Core æºç ](https://github.com/Uniswap/v4-core)
- [Uniswap V4 Periphery](https://github.com/Uniswap/v4-periphery)

**ç¤¾åŒºèµ„æºï¼š**
- [Uniswap Discord](https://discord.gg/uniswap)
- [Uniswap è®ºå›](https://gov.uniswap.org)
- [V4 Hooks ç¤ºä¾‹](https://github.com/Uniswap/v4-periphery/tree/main/src/hooks)

**å¼€å‘å·¥å…·ï¼š**
- [Foundry Book](https://book.getfoundry.sh/)
- [Slither æ–‡æ¡£](https://github.com/crytic/slither)
- [OpenZeppelin åˆçº¦](https://docs.openzeppelin.com/)

---

## æ„Ÿè°¢é˜…è¯»

æ„Ÿè°¢æ‚¨é˜…è¯»ã€Œæ­»ç£•Uniswap V4ã€ç³»åˆ—æ–‡ç« ã€‚å¸Œæœ›è¿™äº›å†…å®¹èƒ½å¸®åŠ©æ‚¨æ·±å…¥ç†è§£Uniswap V4çš„æŠ€æœ¯æ¶æ„ï¼Œå¹¶åœ¨å®é™…å¼€å‘ä¸­åº”ç”¨è¿™äº›çŸ¥è¯†ã€‚

å¦‚æœæ‚¨æœ‰ä»»ä½•é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»ï¼š
- æäº¤ Issue
- å‘é€ Pull Request
- å‚ä¸ Discord è®¨è®º

ç¥æ‚¨åœ¨DeFiå¼€å‘ä¹‹æ—…ä¸­ä¸€åˆ‡é¡ºåˆ©ï¼

---

## å‚è€ƒèµ„æ–™

- [Uniswap V4 Core - PoolManager.sol](https://github.com/Uniswap/v4-core/blob/main/src/PoolManager.sol)
- [Uniswap V4 Core - IHooks.sol](https://github.com/Uniswap/v4-core/blob/main/src/interfaces/IHooks.sol)
- [Smart Contract Security Best Practices](https://consensys.github.io/smart-contract-best-practices/)
- [SWC Registry](https://swcregistry.io/)
- [Ethereum Smart Contract Best Practices](https://forum.openzeppelin.com/t/ethereum-smart-contract-best-practices/2334)
