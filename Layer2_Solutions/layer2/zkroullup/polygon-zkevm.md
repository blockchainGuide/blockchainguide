https://wiki.polygon.technology/docs/home/polygon-basics/zkEVM-basics/

![image-20221118162953707](/Users/carver/Library/Application Support/typora-user-images/image-20221118162953707.png)

zk node 的运行者可以当聚合器或者排序器

**Sequencer**：

收集事务并成批发布它们

从公布的交易中收取费用

支付 L1交易费 + MATIC (取决于未完成的批次)

MATIC 到聚合器

有利可图，如果: txs 费用 > L1 调用 + MATIC网络支付的 fee 



**Aggregator**

处理Sequencers发布的事务

构建zkProof

从Sequencer接收MATIC

静态成本：L1 合约调用成本+服务成本（用于构造证明）

盈利条件：MATIC支付的fee>L1 合约调用成本+服务成本（用于构造证明）



ZK provider

zkEVM采用先进的零知识技术来创建有效性证明。它使用了一个零知识证明器（zkProver），该证明器旨在在任何服务器上运行，并且经过设计与大多数消费者硬件兼容。每个聚合者将使用此zkProver验证批次并提供有效性证明。

它由一个主状态机执行器、一组辅助状态机（每个都有自己的执行器）、一个STARK证明生成器和一个SNARK证明生成器组成。

![image-20221121110155723](/Users/carver/Library/Application Support/typora-user-images/image-20221121110155723.png)

------



























 **LX-LY bridge**

LX-LY桥是一个智能合约，允许用户在LX和LY两层之间转移资产。zkEVM中的L1-L2是安全存款和提取资产的分散桥梁。它是两个智能合约的组合，一个部署在一个链上，另一个部署到另一个链。

zkEVM中的L1和L2合约是相同的，除了每个合约的部署位置。桥L1合约位于以太坊主网上，用于管理rollup之间的资产转移，而桥L2合约位于特定rollup上，负责主网和rollup（或汇总）之间的资产传输。

第2层互操作性允许本地机制在不同的L2网络之间迁移资产。此解决方案嵌入到网桥智能合约中。



verifyer

验证者是一个智能合同，它能够验证任何 ZK-SNARK 加密证明。该 SNARK 验证器证明了批处理中每个事务的有效性。它是任何 zk-Rollup 体系结构中的关键实体，主要原因是它验证了确保有效状态转换的 Proof 的正确性

交易生命周期

在使用 L2进入事务流之前，用户需要一些资金来执行任何 L2事务。为此，用户需要通过 zkEVM 桥 dApp 将一些以太从 L1传输到 L2。

桥：

- 质押以太
- 等待直到在L2上发布globalExitRoot
- 对 L2进行索赔并收到资金

L2 交易：

- 用户在钱包中初始化 tx (例如 Metamask)并将其发送给一个序列器（Sequencer）
- 一旦Sequencer提交添加其事务，它将在L2上完成
- 事务已经在 L2上完成，但在 L1上没有完成(简单地说，L2状态还没有在 L1上完成)。也被称为信任状态
- 顺序器将批处理数据发送到 L1智能契约，使任何节点都能以不可信的方式从 L1进行同步(又名虚拟状态)
- 聚合器将对待定交易进行验证，并构建证明，以实现L1的最终性
- 一旦证明被验证，用户的事务将达到 L1最终结果(对取款很重要) ，这被称为统一状态。

效率是网络性能的关键。zkEVM应用了几种实现策略来保证效率。以下列出了其中一些：

- 第一个策略是部署 PoE，它激励最有效的聚合器参与证明生成过程
- 第二个策略是执行所有的脱链计算，同时只保留必要的数据和 zk 证明在链上。
- 桥接智能契约的实现方式，例如仅使用 Exit Tree Roots 以 UTXO 方式结算帐户。
- 在zkProver中使用专门的加密原语，以加快计算速度并最小化证明大小，如所示：
  - 运行一种特殊的零知识汇编语言(zkASM)来解释字节码
  - 使用诸如 zk-STARK 之类的零知识工具进行证明; 这些证明虽然规模较大，但速度非常快。
  - 一个 zk-SNARK 被用来证明 zk-STARK 证明的正确性，而不是发布大量的 zk-STARK 证明作为有效性证明。这些 zk-SNARK 反过来作为状态变化的有效性证据发布。这有助于将天然气成本从5M 降低到350K。

## POE 

效率证明（PoE）模型利用了现有的PoD机制，并支持多个协调员无权限参与，以在L2层中生成批次。这些批次是从第1层的汇总事务中创建的。PoE采用了一种更简单的技术，由于其在解决PoD中所涉及的挑战方面具有更高的效率，因此备受青睐。

- 维护其无许可功能以生产L2批次
- 高效，这是整个网络性能的关键标准
- 达到可接受的权力下放程度
- 免受恶意攻击，尤其是验证程序的攻击
- 在整体验证工作和网络价值之间保持一个公平的平衡

**链上数据可用性：**

完整ZK汇总模式需要发布链上的数据（用户需要重建完整状态）和有效性证明（零知识证明）。然而，考虑到以太坊配置，在链上发布数据会导致天然气价格上涨，这是第1层的问题。这使得在完整ZK汇总配置和混合配置之间做出决定具有挑战性。

在混合模式下，可以执行以下任一操作：

有效性：数据存储在链外，只有有效性证明在链上发布。

Volition：对于某些交易，数据和有效性证明都保持在链上，而对于其余的交易，只有证明继续链上。

除非证明模块能够高度加速以降低验证器的成本，否则混合模式仍然可行。

**POE合约**

zkEVM中的底层协议通过使用有效性证明来确保状态转换正确。为了确保已遵循一组预先确定的规则来允许状态转换，采用了效率证明智能合约。效率证明（PoE）智能合约目前部署在Goerli测试网上（https://goerli.etherscan.io/address/0x14cB06e8dE2222912138F9a062E5a4d9F4821409）



智能合约验证有效性证明，以确保每个转换都正确完成。这是通过使用zk-SNARK电路实现的。这种类型的系统需要两个过程：事务批处理和事务验证。

为了执行这些过程，zkEVM使用了两种参与者：序列器和聚合器。在此两层模型下：

序列器→ 向网络提出事务批处理，即它们成批汇总事务请求并将其添加到PoE智能合约中。

聚合器→ 检查交易批次的有效性并提供有效性证明。任何无权限聚合器都可以提交证明，以证明状态转换计算的正确性。

因此，PoE智能合约发出两个调用：一个调用从序列器接收批，另一个调用聚合器，请求验证批。

因此，PoE智能合约发出两个调用：一个调用从序列器接收批，另一个调用聚合器，请求验证批。

![image-20221121142228438](/Users/carver/Library/Application Support/typora-user-images/image-20221121142228438.png)

PoE智能合约对序列器和聚合器提出了以下要求：

任何拥有运行zkEVM节点所需软件的人都可以是Sequencer。

每个Sequencer必须以MATIC代币的形式支付费用，以获得创建和提议批次的权利。

提出有效批次（由有效交易组成）的排序器，由交易请求者或网络用户支付的费用激励。



排序器：

任何拥有运行zkEVM节点所需软件的人都可以是Sequencer。

每个Sequencer必须以MATIC代币的形式支付费用，以获得创建和提议批次的权利。

提出有效批次（由有效交易组成）的排序器，由交易请求者或网络用户支付的费用激励。

聚合器：

聚合器从序列器接收所有事务信息，并将其发送给证明器，证明器在复杂的多项式计算后提供一个小的zk证明。智能合约验证了这一证明。这样，聚合器收集数据，将其发送给证明器，接收其输出，最后将信息发送给智能合约，以检查证明器的有效性证明是否正确。

聚合器的任务是为Sequencers提出的L2事务提供有效性证明。

除了运行zkEVM的zkNode软件外，聚合器还需要有专门的硬件来使用zkProver创建零知识有效性证明。

对于给定批次，提交有效性证明的聚合者首先获得MATIC费用（由该批次的排序者支付）。

聚合者需要表明其验证交易的意图。之后，他们根据自己的策略竞争产生有效性证明。

## zkNode

zkNode是运行zkEVM节点所需的软件。网络需要客户端来实现同步并管理参与者（序列器或聚合器）的角色。Polygon zkEVM参与者将选择参与方式：

作为了解网络状态的节点，或

作为批量生产过程的参与者，担任两个角色中的任何一个：序列者或聚合者, zkNode体系结构本质上是模块化的。

![image-20221121143109745](/Users/carver/Library/Application Support/typora-user-images/image-20221121143109745.png)

---

## 排序器

Sequencer从用户接收L2事务，将其作为新的L2批处理，然后将该批作为有效的L2事务提交给PoE智能合约。Sequencer从用户处接收交易，并将从所有已发布的交易中收取所有费用。因此，为了从中获得最大利润，从经济上激励测序者发布有效交易。通常使用带有排序算法的交易池来选择最有利可图的交易来解决这一问题

发布一系列交易时，Sequencer必须支付MATIC代币费用。此金额将根据需要验证的待定批次而变化。如果序列器通过发布无效事务或仅使用一个事务创建批处理来显示恶意行为，则该协议将确保断开链的代价非常高昂。这确保发布无效事务将导致序列器丢失。

序列器可以是受信任的或无权限的：

t rusted:

为了实现快速的最终结果，在网络中增加了可信序列。在 L1上实现虚拟化之前，受信任的序列程序可以预测状态的样子。

无许可的：

为了改进Polygon zkEVM的去中心化，我们允许无权限序列器在网络上运行。任何具有所需硬件设置的人都可以初始化自己的zkNode，并作为独立的、抗审查的、无权限的定序器参与网络。

聚合器：

聚合器从序列器接收所有事务信息，并将其发送给验证器（或zkProver），后者在复杂的多项式计算后提供字节大小的zk证明。智能合约验证了这一证明。通过这种方式，聚合器收集数据，将其发送到验证器，接收其输出，最后将信息发送到智能合约，以验证验证器的有效性证明是否正确。

定序器支付的MATIC费用将支付给聚合器。如果链上的批量过多，MATIC成本将增加，这将更好地激励聚合器生成可验证的证据。运行聚合器的总成本由两个因素计算：L1事务成本和服务器成本（待定）。



同步器：

除了排序和验证过程之外，zkNode还支持批处理及其有效性证明的同步，这只有在将这些批处理添加到L1之后才会发生。这是使用名为Synchronizer的子组件完成的。

同步器负责从智能合约中获取所有数据，包括排序器发布的数据（事务）和聚合器发布的信息（有效性证明）。所有这些数据都存储在一个巨大的数据库中，并通过名为JSON-RPC的服务提供给第三方。

同步器负责从以太坊区块链读取事件，包括新的批次，以保持状态完全同步。从这些事件中读取的信息必须存储在数据库中。同步器还处理可能的重组，这将通过检查最后一个ethBlockNum和最后一个ethBlockHash是否同步来检测。

RPC：

RPC (远程过程调用)是一个与以太网兼容的 JSON-RPC 接口。对于一个软件应用程序与以太链交互(通过读取区块链数据和/或向网络发送事务) ，它必须连接到一个以太节点。RPC 支持将 zkEVM 与现有工具集成，如 Metamask、 ethercan 和 Infura。它将事务添加到 Pool，并使用只读方法与 State 进行交互。

state：

此子组件实现Merkle树并连接到DB后端。它检查区块级别的完整性（与天然气和区块大小等相关的信息）和一些与交易相关的信息（签名、足够的余额）。它还将智能合约代码存储到Merkle树中，并使用EVM处理事务。



z  provider:

事务的所有有效规则都在 zkProver 中实现和执行。ZkProver 以多项式和汇编语言的形式执行复杂的数学计算。这些内容稍后将在智能合同上进行验证。

这些规则可以看作是事务为了能够修改状态树或退出树而必须满足的约束。ZkProver 是最复杂的模块，需要开发两种新的编程语言来实现所需的元素。这里概述了它的详细体系结构。



## ZKP ro vi de r

多边形 zkEVM 完整性的核心是它的零知识证明器，又名 zkProver。

本文档提供了 zkProver 的详细架构描述，而没有深入探究其技术复杂性。此外，它还简要地描述了它的状态机，这里有完整的文档说明。

https://docs.hermez.io/zkEVM/zkProver/State-Machines/Overview/zkProver-State-Machines/#introduction

### 介绍



