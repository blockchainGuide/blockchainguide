> - optimism æ ‡å‡†æ¡¥ æä¾›ä¸¤ä¸ªç½‘ç»œä¹‹é—´ç§»åŠ¨èµ„äº§ï¼Œæ¯”å¦‚L1å­˜å…¥100ç¾å…ƒCï¼Œæ¥æ¢å–L2ä¸Š100ç¾å…ƒCï¼Œ
>
> - éœ€è¦æˆæƒç»™æ ‡å‡†æ¡¥æ¥å­˜å…¥ERC20
>
> - æ ‡å‡†ç½‘æ¡¥åªèƒ½ä¸åœ¨**Optimismä¸Šæ­£ç¡®é…ç½®äº†ERC-20**ç‰ˆæœ¬çš„ä»¤ç‰Œä¸€èµ·ä½¿ç”¨ã€‚å¦‚æœæ‚¨å°†ä»»ä½•å…¶ä»–ç±»å‹çš„ä»¤ç‰Œç›´æ¥å‘é€åˆ°æ ‡å‡†ç½‘æ¡¥ï¼ˆä¸ä½¿ç”¨ç”¨æˆ·ç•Œé¢æˆ–APIï¼‰ï¼Œå®ƒå°±ä¼šè¢«å¡ä½ï¼Œä»è€Œå¤±å»è¯¥å€¼ã€‚token[æŸ¥çœ‹åœ°å€](https://static.optimism.io/optimism.tokenlist.json)ï¼Œæœ‰`optimismBridgeAddress`æ‰å¯ä»¥ä½¿ç”¨æ­¤æ ‡å‡†æ¡¥
> - åœ¨ä»¤ç‰Œåˆ—è¡¨ä¸­å­˜åœ¨å¯ä»¥é€‰æ‹©ä½¿ç”¨optimismæ ‡å‡†ç½‘æ¡¥æˆ–è€…ä½¿ç”¨å…¶ä»–ä¸åŒçš„ç½‘æ¡¥ï¼Œæç°åœ¨extensions.optimismBridgeAddresså€¼ä¸åŒã€‚

## IL1ERC20Bridge

```solidity
 // è·å–å¯¹åº”çš„L2ç½‘æ¡¥åˆçº¦çš„åœ°å€
 function l2TokenBridge() external returns (address);
 
 // å°†ERC20çš„ä¸€éƒ¨åˆ†å­˜å…¥calleråœ¨L2ä¸Šçš„ä½™é¢ 
 function depositERC20(
   address _l1Token, // æˆ‘ä»¬å­˜æ”¾çš„L1 ERC20çš„åœ°å€
   address _l2Token, // L1å„è‡ªçš„L2 ERC20çš„åœ°å€
   uint256 _amount,  // ERC20å­˜æ¬¾é‡‘é¢
   uint32 _l2Gas,    // å®Œæˆ L2ä¸Šçš„å­˜æ¬¾æ‰€éœ€çš„æ°”ä½“é™é¢
   bytes calldata _data // è¦è½¬å‘åˆ°L2çš„å¯é€‰æ•°æ® ğŸš© å¤–éƒ¨è°ƒç”¨ä¼ é€’çš„ä»€ä¹ˆæ•°æ®
 ) external;
 
 // å°†ä¸€ç¬” ERC20å­˜å…¥æ¥å—è€…åœ¨ L2ä¸Šçš„ä½™é¢
 function depositERC20To(
   address _l1Token,
   address _l2Token,
   address _to,  // å°†å–æ¬¾è®°å…¥è´·æ–¹çš„L2åœ°å€
   uint256 _amount,
   uint32 _l2Gas,
   bytes calldata _data
   ) external;
    
  // å®Œæˆä»L2åˆ°L1çš„å–æ¬¾ï¼Œå¹¶å°†èµ„é‡‘è®°å…¥L1 ERC20ä»£å¸çš„æ¥æ”¶è€…ä½™é¢
	function finalizeERC20Withdrawal(
    address _l1Token, // è¦ç»ˆç»“çš„L1ä»¤ç‰Œçš„åœ°å€
    address _l2Token, // å¼€å§‹ææ¬¾çš„ L2ä»¤ç‰Œåœ°å€
    address _from,    // å¯åŠ¨ä¼ è¾“çš„L2åœ°å€
    address _to,      // å°†å–æ¬¾è®°å…¥è´·æ–¹çš„L1åœ°å€ã€‚
    uint256 _amount,  // è¦å­˜å…¥çš„ERC20é‡‘é¢
    bytes calldata _data // å‘é€æ–¹åœ¨L2ä¸Šæä¾›çš„æ•°æ®
  ) external;
```



## L1StandardBridge

> æ ‡å‡†æ¡¥çš„L1éƒ¨åˆ†ã€‚è´Ÿè´£å®ŒæˆL2çš„å–æ¬¾ï¼Œå¹¶å‘ETHå’Œ**ç¬¦åˆERC20**çš„L2å‘èµ·å­˜æ¬¾ï¼Œæ”¯æŒETHå’ŒETHä¸Šçš„ERC20



### ä»L1å­˜å…¥é‡‘é¢åˆ°L2

å­˜å…¥é‡‘é¢è°ƒç”¨çš„æ˜¯depositETHï¼Œè¿™é‡Œçš„calldatağŸš©, åœ¨å­˜å…¥çš„æ—¶å€™L1æ¡¥åˆçº¦ä¼šè®°å½•L1åœ°å€æ˜ å°„åˆ°L2åœ°å€æ‰€å­˜å…¥çš„é‡‘é¢.

QAï¼š ä¸ºä»€ä¹ˆéœ€è¦åœ°å€åˆ«å

- https://community.optimism.io/docs/developers/build/differences/#using-eth-in-contracts
- https://community.optimism.io/docs/developers/build/differences/#accessing-the-latest-l1-block-number

QA : l2gas æ˜¯å¦‚ä½•è·å–L2ä¸Šçš„gasçš„

QA ï¼š finalizeDepositä¼ è¾“é›¶åœ°å€çš„æ„æ€

```solidity
  // å°†L1ä»¤ç‰Œæ˜ å°„åˆ°L2ä»¤ç‰Œï¼Œä»¥å­˜å‚¨L1ä»¤ç‰Œçš„ä½™é¢
  mapping(address => mapping(address => uint256)) public deposits;
  
 function depositETH(uint32 _l2Gas, bytes calldata _data) external payable onlyEOA {
        _initiateETHDeposit(msg.sender, msg.sender, _l2Gas, _data);
    }
    
function _initiateETHDeposit(
        address _from,
        address _to,
        uint32 _l2Gas,
        bytes memory _data
    ) internal {
        // å­˜å…¥ETHå’Œå­˜å…¥ERC20æ˜¯ä¸ä¸€æ ·çš„å‚æ•°ä¼ é€’ï¼Œ å­˜å…¥ETHï¼Œ _l2Token æ°¸è¿œæ˜¯OVM_ETHåœ°å€
        // _l1Token æ°¸è¿œæ˜¯ address(0)
        bytes memory message = abi.encodeWithSelector(
            IL2ERC20Bridge.finalizeDeposit.selector,
            address(0),
            Lib_PredeployAddresses.OVM_ETH,
            _from,      // ä»L1æå–å­˜æ¬¾çš„å¸æˆ· msg.sender
            _to,        // L2ä¸Šçš„å­˜æ¬¾è´¦æˆ·    msg.sender  ğŸš©è¿™ä¸ªè´¦æˆ·åœ°å€éš¾é“ä¸ä¼šå’ŒL1ä¸€æ ·ï¼Œä½†æ˜¯å±äºä¸åŒäººåˆ›å»ºçš„ï¼Ÿ é™¤éè¿™æ¡é“¾ä¸æ”¯æŒåˆ›å»ºè´¦æˆ·ï¼Œä¸ç„¶è¿™é’±ä¸å°±æœ‰ç¬¬äºŒä¸ªäººçŸ¥é“äº†ï¼Ÿ
            msg.value,
            _data
        );

        // Send calldata into L2
        // slither-disable-next-line reentrancy-events
        sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);

        // slither-disable-next-line reentrancy-events
        emit ETHDepositInitiated(_from, _to, msg.value, _data);
    }

```

 IL2ERC20Bridge.finalizeDeposit.selector è®¾ç½®äº†ä¸€ä¸ª**L2**ä¼šè°ƒç”¨çš„å‡½æ•° finalizeDeposit:

```solidity
finalizeDeposit å®Œæˆä»L1åˆ°L2çš„å­˜æ¬¾ï¼Œå¹¶å°†èµ„é‡‘è®°å…¥è¯¥L2ä»£å¸çš„æ¥æ”¶è€…ä½™é¢ã€‚å¦‚æœè¯¥è°ƒç”¨ä¸æ˜¯æ¥è‡ªL1StandardTokenBridgeä¸­çš„ç›¸åº”å­˜æ¬¾ï¼Œåˆ™è¯¥è°ƒç”¨å°†å¤±è´¥ã€‚ 
è¿™ä¸ªåªèƒ½ è·¨é“¾è´¦æˆ·å»è°ƒç”¨,å°†ç›¸åŒæ•°é‡çš„é‡‘é¢å­˜å…¥åˆ°L2çš„è´¦æˆ·
function finalizeDeposit(
        address _l1Token,  // ç”¨äºè°ƒç”¨çš„l1ä»¤ç‰Œçš„åœ°å€
        address _l2Token,  // ç”¨äºè°ƒç”¨çš„l2ä»¤ç‰Œçš„åœ°å€
        address _from,     // ä»L2æå–å­˜æ¬¾çš„å¸æˆ·ã€‚
        address _to,       // æ¥æ”¶å–æ¬¾çš„åœ°å€
        uint256 _amount,
        bytes calldata _data
    ) external;
```



åˆ°äº†è¿™é‡Œå®é™…æ˜¯L1çš„åˆçº¦è·¨é“¾è°ƒç”¨L2 çš„åˆçº¦ï¼Œ sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);ï¼Œè°ƒç”¨çš„CrossDomainEnabledï¼ˆä¸“é—¨åšè·¨é“¾æ¶ˆæ¯ä¼ é€çš„åˆçº¦ï¼‰

```solidity
// L1StandardBridge
// Send calldata into L2
sendCrossDomainMessage(l2TokenBridge, _l2Gas, message);

function sendCrossDomainMessage(
        address _crossDomainTarget,  // l2TokenBridgeåœ°å€
        uint32 _gasLimit,
        bytes memory _message
    ) internal {
        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);
    }
```

å…¶å®åˆ°è¿™é‡Œï¼Œç»„è£…äº†ä¸€ä¸ªè°ƒç”¨æ¶ˆæ¯ï¼Œæ˜¯è®©L2å»è°ƒç”¨è‡ªå·±çš„æ–¹æ³•ï¼ŒåŒ…æ‹¬L2çš„åˆçº¦åœ°å€ï¼ŒL2gaså’ŒL2çš„ABIä¿¡æ¯ï¼ˆä¼ å…¥äº†L1çš„å‚æ•°ï¼‰ï¼Œ

æœ€ç»ˆä¼šæŠŠç»„è£…çš„è°ƒç”¨æ¶ˆæ¯äº¤ç»™è·¨é“¾åˆçº¦ã€‚

è·¨é“¾åˆçº¦ä¸»è¦åšäº†ä»¥ä¸‹äº‹æƒ…ï¼š

- å°†CTCé˜Ÿåˆ—ç›®å‰é•¿åº¦ä½œä¸ºnonce 
- æ„é€ è·¨é“¾calldataï¼ˆç¼–ç çš„è·¨é“¾da taä¸­çš„m s g.senderåº”è¯¥æ˜¯L1æ¡¥çš„åœ°å€ï¼‰
- **å‘é€è·¨é“¾æ¶ˆæ¯ï¼ˆæœ€ç»ˆå‡ºå£ï¼‰**ç»™CanonicalTransactionChainï¼ˆ**L1ä¸Šçš„åˆçº¦**ï¼‰ åˆçº¦ï¼Œ åŒæ—¶ä¼šå°†æ­¤æ¶ˆæ¯å­˜å‚¨åœ¨CanonicalTransactionChainåˆçº¦ä¸Šé€šè¿‡enqueueï¼Œè¿™æ ·L1ä¸Šçš„å·¥ä½œå®Œæˆï¼ŒL1ä¿å­˜äº†è¿™ä¸ªæ¶ˆæ¯ï¼ŒåŒæ—¶è§¦å‘äº‹ä»¶SentMessageï¼ˆL1CrossDomainMessanger.solï¼‰, è°ä¼šå»åšç›‘å¬ï¼Ÿï¼Ÿï¼Ÿï¼Ÿ
  - enqueue ä¼šå°†æ•´ä¸ªL1å­˜å…¥tokençš„ä¸€è¿ä¸²çš„æ•°æ®åŒ…æ‹¬å‘é€è€…ï¼ŒL2ç›®æ ‡tokenåˆçº¦ï¼Œäº¤æ˜“data keccak256ä½œä¸ºä¸€ç¬”äº¤æ˜“ä»¥åŠæ—¶é—´æˆ³å’Œå½“å‰åŒºå—æ‰“åŒ…æˆElementså­˜å…¥CanonicalTransactionChainï¼Œå¹¶è§¦å‘TransactionEnqueuedäº‹ä»¶ï¼ˆæ­¤äº‹ä»¶ç”±DTLç›‘å¬ï¼‰
- ovmCanonicalTransactionChainï¼ˆé¢„å…ˆéƒ¨ç½²ï¼‰ åˆçº¦åœ°å€ï¼š0x4200000000000000000000000000000000000007

```solidity
// L1CrossDomainMessenger.sol
function sendMessage(
        address _target,
        bytes memory _message,
        uint32 _gasLimit
    ) public {
        address ovmCanonicalTransactionChain = resolve("CanonicalTransactionChain");
        // Use the CTC queue length as nonce
        uint40 nonce = ICanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLength();

        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(
            _target, // L2tokenBridge
            msg.sender,  // ï¼Ÿæ˜¯å¦æ˜¯DomainMessenger
            _message,  // å­˜æ¬¾æ¶ˆæ¯
            nonce
        );

        _sendXDomainMessage(ovmCanonicalTransactionChain, xDomainCalldata, _gasLimit);
        
        emit SentMessage(_target, msg.sender, _message, nonce, _gasLimit);
    }
```

```solidity
    function _sendXDomainMessage(
        address _canonicalTransactionChain,
        bytes memory _message,
        uint256 _gasLimit
    ) internal {
        ICanonicalTransactionChain(_canonicalTransactionChain).enqueue(
            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER, // å°†äº¤æ˜“å‘é€åˆ°çš„ç›®æ ‡L2åˆåŒ
            _gasLimit,
            _message
        );
    }
```

å°†ä¸€ç¬”äº¤æ˜“æ·»åŠ åˆ°é˜Ÿåˆ—ï¼š

- calldataçš„æ•°æ®ä¸è¦å¤§äº50000å­—èŠ‚
- L2 tx gas ç›¸å…³æœ€å¤§100000
- è§¦å‘ TransactionEnqueuedäº‹ä»¶

```solidity
    function enqueue(
        address _target,
        uint256 _gasLimit,
        bytes memory _data
    ) external {
        require(
            _data.length <= MAX_ROLLUP_TX_SIZE,
            "Transaction data size exceeds maximum for rollup transaction."
        );

        require(
            _gasLimit <= maxTransactionGasLimit,
            "Transaction gas limit exceeds maximum for rollup transaction."
        );

        require(_gasLimit >= MIN_ROLLUP_TX_GAS, "Transaction gas limit too low to enqueue.");

        if (_gasLimit > enqueueL2GasPrepaid) {
            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) / l2GasDiscountDivisor;
            uint256 startingGas = gasleft();
            require(startingGas > gasToConsume, "Insufficient gas for L2 rate limiting burn.");

            uint256 i;
            while (startingGas - gasleft() < gasToConsume) {
                i++;
            }
        }
        address sender;
        if (msg.sender == tx.origin) {
            sender = msg.sender;
        } else {
            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);
        }

        bytes32 transactionHash = keccak256(abi.encode(sender, _target, _gasLimit, _data));

        queueElements.push(
            Lib_OVMCodec.QueueElement({
                transactionHash: transactionHash,
                timestamp: uint40(block.timestamp),
                blockNumber: uint40(block.number)
            })
        );
        uint256 queueIndex = queueElements.length - 1;
        emit TransactionEnqueued(sender, _target, _gasLimit, _data, queueIndex, block.timestamp);
    }

```

DTLç»„ä»¶æ˜¯ç”±typescriptå†™çš„ï¼ŒTransactionEnqueuedäº‹ä»¶çš„å¤„ç†å¦‚ä¸‹,ä¼šè§£æäº‹ä»¶å¹¶æŸ¥å‡ºcalldata,å†™å…¥æ•°æ®åº“

```typescript
export const handleEventsTransactionEnqueued: EventHandlerSet<
  TransactionEnqueuedEvent,
  null,
  EnqueueEntry
> = {
  getExtraData: async () => {
    return null
  },
  parseEvent: (event) => {
    return {
      index: event.args._queueIndex.toNumber(),
      target: event.args._target,
      data: event.args._data,
      gasLimit: event.args._gasLimit.toString(),
      origin: event.args._l1TxOrigin,
      blockNumber: BigNumber.from(event.blockNumber).toNumber(),
      timestamp: event.args._timestamp.toNumber(),
      ctcIndex: null,
    }
  },
  storeEvent: async (entry, db) => {
    ...
    await db.putEnqueueEntries([entry])
  },
}
```

æ¥ç€å°±æ˜¯L2geth(sequencer)ä»DTLåŒæ­¥`TransactionEnqueued` äº‹ä»¶ï¼Œè½¬ä¸ºäº¤æ˜“å¹¶æ‰§è¡Œ,è¿™éƒ¨åˆ†åœ¨L2geth/rollup/sync_serviceä¸‹é¢ï¼Œä¸“é—¨ç”±SequencerLoopæ‰§è¡Œ

L2geth é‡Œé¢å­˜å‚¨ç€ä¸€ä¸ªrollupclient,ç”¨æ¥å¯¹DTLè¿›è¡ŒHttpè¯·æ±‚çš„ã€‚è¯·æ±‚æ³¨å†Œçš„è·¯ç”±åœ¨DTL/service.ts

```go
//SequencerLoop æ˜¯åœ¨ sequencer æ¨¡å¼ä¸‹è¿è¡Œçš„è½®è¯¢å¾ªç¯ã€‚å®ƒæ’åº
//äº¤æ˜“ï¼Œç„¶åæ›´æ–° EthContextã€‚

func (s *SyncService) SequencerLoop() {
  ...
	s.sequence();
  ...
}
```

æ‰§è¡Œäº¤æ˜“ä¸»è¦ç”±s.applyTransaction(tx)å®ç°ï¼Œä¼šè°ƒç”¨applyIndexedTransactionï¼Œäº¤æ˜“çš„æ¥æºæ˜¯æŒ‡L1 batchï¼Œæˆ–è€…æ˜¯sequenceråŒæ­¥DTLä¸­çš„Transactionenqueuedäº‹ä»¶çš„äº¤æ˜“ã€‚

```go
func (s *SyncService) syncQueueTransactionRange(start, end uint64) error {
	log.Info("Syncing enqueue transactions range", "start", start, "end", end)
	for i := start; i <= end; i++ {
		tx, err := s.client.GetEnqueue(i)
		if err != nil {
			return fmt.Errorf("Canot get enqueue transaction; %w", err)
		}
		if err := s.applyTransaction(tx); err != nil {
			return fmt.Errorf("Cannot apply transaction: %w", err)
		}
	}
	return nil
}
```

applyTransaction æœ€ç»ˆä¼šå°†äº¤æ˜“å‘åˆ°ch:

```GO
s.txFeed.Send(core.NewTxsEvent{
		Txs:   txs,
		ErrCh: errCh,
	})
```

```go
case ev := <-w.rollupCh:
		...				
		if err := w.commitNewTx(tx); err == nil {
		...
```

commitNewTxï¼ˆæäº¤å•ä¸ªäº¤æ˜“DTLæ‰«çš„äº¤æ˜“ï¼‰->applyTransaction->applyMessage->evmæ‰§è¡Œ->writeBlockWithState ï¼Œsequenceræ˜¯é€šè¿‡POAå…±è¯†çš„ã€‚æœ€ç»ˆæŒ–å‡ºä¸€ä¸ªL2çš„åŒºå—å¹¶å†™å…¥æ•°æ®åº“ã€‚åŒæ—¶ç§»é™¤äº†w.chainHeadChæäº¤æŒ–çŸ¿ä»»åŠ¡ï¼Œè¿™æ ·åªèƒ½é€šè¿‡æ‰§è¡ŒåŒæ­¥æœåŠ¡ä»DTLæ‹‰è¿‡æ¥çš„äº¤æ˜“å’Œç”¨æˆ·å‘ç»™sequencerçš„äº¤æ˜“æ¥æ‰§è¡Œç”ŸæˆL2 block .åŒæ—¶æ³¨æ„åˆ°æŠŠTransactionMetaä¹Ÿè®°å½•åˆ°state dbå»äº†ã€‚

ğŸš©è¿™é‡Œå…³äºL1åˆ°L2çš„æ¶ˆæ¯å¦‚ä½•è½¬æ¢æˆl2äº¤æ˜“çš„å…·ä½“è¿‡ç¨‹,æ˜¯éœ€è¦è¯¦ç»†è§£é‡Šçš„ï¼Œè¿™æ‰æ˜¯æ¯”è¾ƒå…³é”®çš„ä¸€æ­¥



batch-submitter ç›‘å¬L2åŒºå—ï¼Œä¼šæ‰“åŒ…txBatch æäº¤åˆ°L1åˆçº¦,é¦–å…ˆä¼šä¸€ç›´åˆ¤æ–­æ˜¯å¦æœ‰L2blockæ›´æ–°ï¼š
```GO
start, end, err := s.cfg.Driver.GetBatchBlockRange(s.ctx)
```

æ¥ç€ä¼šé€šè¿‡CraftBatchTxä½¿ç”¨ç»™å®šçš„nonceå°†å¼€å§‹å’Œç»“æŸä¹‹é—´çš„L2å—è½¬æ¢ä¸ºæ‰¹å¤„ç†äº¤æ˜“ã€‚åœ¨ç”Ÿæˆçš„äº¤æ˜“ä¸­ä½¿ç”¨è™šæ‹Ÿå¤©ç„¶æ°”ä»·æ ¼ï¼Œä»¥ç”¨äºè§„æ¨¡ä¼°è®¡ã€‚

```GO
tx, err := s.cfg.Driver.CraftBatchTx(
				s.ctx, start, end, nonce,
			)
```

æ‰¹å¤„ç†äº¤æ˜“è½¬æ¢å®Œæˆäº†ä¹‹åè¿˜æ˜¯ä¼šè°ƒç”¨ï¼Œbatch-submitterä¼šä½¿ç”¨L1çš„å®¢æˆ·ç«¯å»å‘é€è¿™ç¬”äº¤æ˜“:

```GO
tx, err := d.rawCtcContract.RawTransact(opts, calldata)

func (c *BoundContract) transact(opts *TransactOpts, contract *common.Address, input []byte) (*types.Transaction, error) {
	var err error

	// Ensure a valid value field and resolve the account nonce
	value := opts.Value
	if value == nil {
		value = new(big.Int)
	}
	var nonce uint64
	if opts.Nonce == nil {
		nonce, err = c.transactor.PendingNonceAt(ensureContext(opts.Context), opts.From)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve account nonce: %v", err)
		}
	} else {
		nonce = opts.Nonce.Uint64()
	}
	// Figure out reasonable gas price values
	if opts.GasPrice != nil && (opts.GasFeeCap != nil || opts.GasTipCap != nil) {
		return nil, errors.New("both gasPrice and (maxFeePerGas or maxPriorityFeePerGas) specified")
	}
	head, err := c.transactor.HeaderByNumber(ensureContext(opts.Context), nil)
	if err != nil {
		return nil, err
	}
	if head.BaseFee != nil && opts.GasPrice == nil {
		if opts.GasTipCap == nil {
			tip, err := c.transactor.SuggestGasTipCap(ensureContext(opts.Context))
			if err != nil {
				return nil, err
			}
			opts.GasTipCap = tip
		}
		if opts.GasFeeCap == nil {
			gasFeeCap := new(big.Int).Add(
				opts.GasTipCap,
				new(big.Int).Mul(head.BaseFee, big.NewInt(2)),
			)
			opts.GasFeeCap = gasFeeCap
		}
		if opts.GasFeeCap.Cmp(opts.GasTipCap) < 0 {
			return nil, fmt.Errorf("maxFeePerGas (%v) < maxPriorityFeePerGas (%v)", opts.GasFeeCap, opts.GasTipCap)
		}
	} else {
		if opts.GasFeeCap != nil || opts.GasTipCap != nil {
			return nil, errors.New("maxFeePerGas or maxPriorityFeePerGas specified but london is not active yet")
		}
		if opts.GasPrice == nil {
			price, err := c.transactor.SuggestGasPrice(ensureContext(opts.Context))
			if err != nil {
				return nil, err
			}
			opts.GasPrice = price
		}
	}
	gasLimit := opts.GasLimit
	if gasLimit == 0 {
		// Gas estimation cannot succeed without code for method invocations
		if contract != nil {
			if code, err := c.transactor.PendingCodeAt(ensureContext(opts.Context), c.address); err != nil {
				return nil, err
			} else if len(code) == 0 {
				return nil, ErrNoCode
			}
		}
		// If the contract surely has code (or code is not needed), estimate the transaction
		msg := ethereum.CallMsg{From: opts.From, To: contract, GasPrice: opts.GasPrice, GasTipCap: opts.GasTipCap, GasFeeCap: opts.GasFeeCap, Value: value, Data: input}
		gasLimit, err = c.transactor.EstimateGas(ensureContext(opts.Context), msg)
		if err != nil {
			return nil, fmt.Errorf("failed to estimate gas needed: %v", err)
		}
	}
	// Create the transaction, sign it and schedule it for execution
	var rawTx *types.Transaction
	if opts.GasFeeCap == nil {
		baseTx := &types.LegacyTx{
			Nonce:    nonce,
			GasPrice: opts.GasPrice,
			Gas:      gasLimit,
			Value:    value,
			Data:     input,
		}
		if contract != nil {
			baseTx.To = &c.address
		}
		rawTx = types.NewTx(baseTx)
	} else {
		baseTx := &types.DynamicFeeTx{
			Nonce:     nonce,
			GasFeeCap: opts.GasFeeCap,
			GasTipCap: opts.GasTipCap,
			Gas:       gasLimit,
			Value:     value,
			Data:      input,
		}
		if contract != nil {
			baseTx.To = &c.address
		}
		rawTx = types.NewTx(baseTx)
	}
	if opts.Signer == nil {
		return nil, errors.New("no signer to authorize the transaction with")
	}
	signedTx, err := opts.Signer(opts.From, rawTx)
	if err != nil {
		return nil, err
	}
	if opts.NoSend {
		return signedTx, nil
	}
	if err := c.transactor.SendTransaction(ensureContext(opts.Context), signedTx); err != nil {
		return nil, err
	}
	return signedTx, nil
}
```

å®é™…å°±æ˜¯é€šè¿‡è¿æ¥çš„L1å®¢æˆ·ç«¯å»è°ƒç”¨ç»‘å®šçš„CTCåˆçº¦ï¼ˆCanonicalTransactionChain.appendSequencerBatch()ï¼‰è¿™ä¸ªå‡½æ•°ï¼Œç„¶åè§¦å‘TransactionBatchSubmitteräº‹ä»¶ï¼ŒDTLå†ç›‘å¬è¿™ä¸ªäº‹ä»¶å¹¶å­˜å‚¨ã€‚appendStateBatch() ä¹Ÿæ˜¯ä¸€æ ·ï¼ˆä½†æ˜¯è¿™ä¸ªéƒ½æ˜¯å®ç°çš„CraftBatchTxæ¥å£ï¼Œåˆ°åº•æ˜¯è°ƒå“ªä¸€ä¸ªï¼Œè¿˜æ˜¯éƒ½è°ƒç”¨ï¼‰ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°åˆ†åˆ«å¯¹åº”ChainStorageContainerå’ŒStateCommitmentChainåˆçº¦








### ä»L1å­˜æ¬¾ERC20åˆ°L2

å½“L1ä¸Šå¼€å§‹å­˜æ¬¾æ—¶ï¼ŒL1æ¡¥å°†èµ„é‡‘è½¬ç§»åˆ°è‡ªå·±(L1æ ‡å‡†æ¡¥åˆçº¦ä¸­)ï¼ŒåŒæ—¶åˆçº¦ä¼šè®°å½•L1 -> L2é‡‘é¢çš„æ˜ å°„ï¼Œä»¥å¤‡å°†æ¥å–æ¬¾

ä¸ç®¡æ˜¯å­˜ETHè¿˜æ˜¯å­˜ERC20ï¼Œéƒ½ä¼šè§¦å‘TransactionEnqueuedäº‹ä»¶ï¼ŒDTLå±‚ä¼šå®šæœŸæ‰«L1çš„åŒºå—ï¼Œè·å–è¿™ä¸ªäº‹ä»¶å¹¶å­˜å‚¨åˆ°levelDB



### ä»L2ææ¬¾åˆ°L1







## å‚è€ƒ

- [1] : [optimismæµè§ˆå™¨åˆçº¦](https://optimistic.etherscan.io/address/0xe0bb0d3de8c10976511e5030ca403dbf4c25165b#readContract)
- [2] : [è¯¦ç»†åˆçº¦](https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/contracts/L1/L1StandardBridge.sol)
- [3] : [æ ‡å‡†æ¡¥æ–‡æ¡£](https://community.optimism.io/docs/developers/bridge/standard-bridge/)
- [4] : [tx.origin](https://developer.aliyun.com/article/843855)
- [5] : [æºç åˆ†æ](https://godorz.info/2022/04/optimism-notes/)
- [6] : [æ•°æ®å¯ç”¨æ€§](https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding)
- [7] : [å¤šæ–¹é—¨é™ç­¾å](https://github.com/bnb-chain/tss-lib)
- 
